

Sending emails to users is a common use case in nowadays web applications. The Social Software Extension provides an easy mechanism to send emails to users. To send an email you can use the following code snippet:

Map<String, Object> map = new HashMap<String, Object>();
map.put("userName", user.getName());
map.put("greeting", "Hello");
mailService.send(user, "mail", map, Locale.GERMAN);

In order to finally dispatch the mail the mailService takes the following steps:
Determine the user's email address.
Look up a  localized MessageTemplate by the given name. (This will usually be a MailMessageTemplate)
Create a Message instance from the MessageTemplate and evaluate the template text with the given map.
Dispatch the Message with the help of a MessageTransport.

In the first step the user's email address is resolved by consulting AddressMapping. The second will look up a localized MailMessageTemplate which could look like this:

MailMessageTemplate template = new MailMessageTemplate();
template.setSubject("Mail from CoreMedia");
template.setFrom("mail@coremedia.com");
template.setText("$greeting $userName!\n\nYou have mail.");

In the third step the template's text  property will be evaluated using the passed in map. In the fourth step the MessageTemplate's createMessage is called. The resulting Message is passed to the mailService's MessageTransport in the fifth step, which dispatches the message.

Setting up the Mail Service

An example configuration for the Mail Service can be found in the file config/spring/sse/sse-mail-example.xml.

  <bean id="mailTransport" class="com.coremedia.sseimpl.email.MailTransport">
    <description>
      The MailTransport. Knows how to deliver Messages.
    </description>
    <property name="mailSender">
      <bean class="org.springframework.mail.javamail.JavaMailSenderImpl">
        <property name="host" value="smtp.coremedia.com"/>
      </bean>
    </property>
  </bean>
  
  <bean id="cmsTemplateFinder" parent="defaultTemplateEvaluator"
   class="com.coremedia.sseimpl.email.CmsMailMessageTemplateFinder">
    <description>
      A template finder that looks up MessageTemplates from the CMS.
      The provided basePath has to point to a CMS folder.
    </description>
    <property name="basePath" value="/Mail"/>
    <property name="capConnection" ref="capConnection"/>
  </bean>

  <bean id="resourceBundleTemplateFinder" parent="defaultTemplateEvaluator"
   class="com.coremedia.sseimpl.email.MessageSourceMailTemplateFinder">
    <description>
      A template finder that looks up MessageTemplates from a given ResourceBundle.
      You may add your own MessageSource.
    </description>
    <property name="messageSource">
      <bean class="org.springframework.context.support.ResourceBundleMessageSource">
        <property name="basenames">
          <description>
            A list of ResourceBundles to search for messages.
            Be aware that the search order is important:
            First come wins.
          </description>
          <list>
            <value>com.coremedia.sse.example.Mail</value>
          </list>
        </property>
      </bean>
    </property>
  </bean>

  <bean id="mailService" class="com.coremedia.sse.messaging.DefaultMessageService">
    <description>
      The Mail Service bean.
    </description>
    <property name="messageTransport" ref="mailTransport">
    </property>
    <property name="addressMapping">
      <description>
        Determines from where a User's email address should be retrieved.
      </description>
      <bean class="com.coremedia.sse.messaging.DefaultAddressMapping">
        <property name="baseModule" ref="baseModule"/>
      </bean>
    </property>
    <property name="templateFinder" ref="cmsTemplateFinder"/>
  </bean>

  <bean id="defaultTemplateEvaluator" abstract="true">
    <property name="templateEvaluator" ref="templateEvaluator"/>
  </bean>

  <bean id="templateEvaluator" class="com.coremedia.sseimpl.util.VelocityTemplateEvaluator">
    <description>
      The default evaluator for MessageTemplates. Is responsible for rendering the message body.
      Velocity is used as the templating language.
    </description>
    <property name="velocityEngine" ref="velocityEngine"/>
  </bean> 

  <bean id="velocityEngine" class="org.springframework.ui.velocity.VelocityEngineFactoryBean"/>
  
</beans>

In order to get up on your feet quickly you need to do two things. Tell the Mail Service where to find a user's email address and where to find the mail templates.

Step 1: Retrieving a user's address

You may use the interface AddressMapping to determine a user's address.
The default implementation AddressMappingImpl will look up the emailAddress property on the user's VCard. You can configure which property to look up on which ProfileCard.

<bean id="addressMapping" class="com.coremedia.sse.messaging.DefaultAddressMapping">
  <description>
    The AddressMapping is responsible for mapping User's to addresses and vice versa.
    The properties below show the default configuration. If you're fine with these you can
    use the DefaultAddressMapping unconfigured. 
  </description> 
  <property name="baseModule" ref="baseModule"/>
  <property name="propertyName" value="emailAddress"/>
  <property name="profileCardType">
    <util:property-path path="baseModule.vCardType"/>
  </property>
</bean>

To customize the DefaultAddressMapping use a different propertyName and profileCardType.

Step 2: Finding a message template

You can either store your mail templates in ResourceBundle and access them via MessageSourceMailTemplateFinder or retrieve them via an UAPI connection by using the CmsMailMessageTemplateFinder.
In both cases you have to adhere to a naming scheme. Mail templates are looked up by name. In the former variant the template name corresponds to a message key. When using the latter variant the template name must match a CMS Content name.


When using the ResourceBundle variant you should define some property files like this:

#mail.properties
mail.subject=Hello!
mail.from=mail@example.coremedia.com
mail.text=$greeting $userName \nI'm sending some mail. I can even use Velocity templates if I like to. 

#mail_de.properties
mail.subject=Hallo!
mail.from=mail@example.coremedia.com
mail.text=$greeting $userName \nIch versende eine Mail. I kann sogar Velocity-Templates benutzen.

Now when you look up the mail template named "mail" the TemplateFinder will look through the ResourceBundles and retrieve a localized
version of your mail template.

Storing mail templates in the CMS works in a similar fashion. Decide on a path where to store your templates, i.e. "/Mail".
Now create various documents like "mail", "mail_de", "mail_fr". The documents should be of the following type:

  <DocType Name="Mail">
    <StringProperty Name="subject" Length="128" />
    <StringProperty Name="from" Length="128" />
    <BlobProperty Name="text" MimeType="text/plain"/>    
  </DocType>

Step 3: Creating the Message instance

The mailService passes the address found by consulting the AddressMapping and the map to the MessageTemplate once it has been found. The TemplateFinder also sets a TemplateEvaluator on the MessageTemplate to be used for evaluating the text body of the Message.

MailMessageTemplate template = new MailMessageTemplate();
Map map = new HashMap();
map.put("userName", user.getName());
map.put("greeting", "Hello");
Message msg = template.createMessage("lisa@simpsons.com", map);

In the examples above both template finders are configured with a default TemplateEvaluator. A TemplateEvaluator is responsible for evaluating the variables in the MessageTemplate's text property and return the rendered string. Usually you would want to pass variables like userName, date, url or other aspects that need to be set dynamically to the MessageTemplate. The default evaluator supplied with the Social Software Extension is the VelocityTemplateEvaluator which uses the powerful Velocity templating engine. If you would like to use a different templating engine or create your own, implement the TemplateEvaluator interface. It's up to you if you even want to use a TemplateEvaluator or rather implement the evaluation logic in your MessageTemplate implementation. The TemplateEvaluator interface is only provided for convenience. When using the upper configuration for instance msg.getText() would be:

Hello Lisa!
I'm sending some mail. I can even use Velocity templates if I like to.

Step 4: Dispatching the Message

Once your Message instance has been created, the mailService passes it to it's messageTransport. The sole responsibility of a MessageTransport is to send out the message. It knows about a Message's protocol. In case of an email the MessageTransport would open an SMTP connection etc. Your own implementation could send out Messages via SMS or relay them to one of the many social networks. 

