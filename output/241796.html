<div xmlns="http://www.coremedia.com/2003/richtext-1.0" xmlns:xlink="http://www.w3.org/1999/xlink"><p>Having opened a <span class="inlineformat--code">CapConnection</span>, all actions are executed on behalf of the single user whose credentials where provided when logging in. In some contexts, it is desirable to use different users for different tasks while maintaining a shared cache. To this end, the <em>Unified API</em> allows you to use multiple sessions per connection. </p><p>Every session is represented by an instance of <span class="inlineformat--code">CapSession</span>. The session that is created while the connection is opened is also known as the <em>connection session</em>. Additional sessions can be opened by the connection's login methods. Having obtained a session, this session can replace the default connection session by calling the method <span class="inlineformat--code">setSession(CapSession)</span> on the connection. Afterwards, all accesses in the same thread that set the session are performed on behalf of the new session.</p><p class="p--codeblock">CapSession session = connection.login(user, password);<br/>connection.setSession(session);<br/>...<br/>session.close();</p><p>The previous code fragment shows how a second session is created from an existing connection. Notice that the call to <span class="inlineformat--code">setSession</span> was necessary, because the login call does not automatically set the session. Only between <span class="inlineformat--code">setSession</span> and <span class="inlineformat--code">close</span> we can see the newly created user as the user of the current session. In fact, in other threads the original session still applies. After closing the session, the connection session is again active.</p><p>In other cases you might want to save the original session and reestablish it after the work of the second session is complete, without closing the second session. That way you can save the time that is required for opening the session. Of course, a session that is held open consumes a concurrent license all the time.</p><p>All accesses to the repositories are subject to the limitations of the requested session. During reads and writes, the rights check is based on the identity of the session's user. Write rights may happen to be reduced, but it is also possible that additional rights are gained by switching to another user. However, the read rights available to any session are at most the read rights of the connection session. This is required in order to ensure efficient caching and to avoid accidental information leaks. Due to this restriction, it is recommended that the connection session's user should be allowed to read all repositories in their entirety, if additional sessions are expected to be created.</p><p>When attaching a listener using the <em>Unified API</em>, the current session is recorded. Before events are delivered to the listener, that session is re-established as the current session. This way, listeners inherit the privileges of the code that attaches them.</p><p>Note that it is always possible to reset the current session to the connection session. Therefore, setting the current session is not sufficient for enforcing access restrictions when a <span class="inlineformat--code">CapConnection</span> object is passed to untrusted code. Multiple sessions show their greatest potential in trusted applications which receive help in restricting user views while maintaining a shared cache.</p><p>Certain privileged connections have the ability to create new sessions for arbitrary users without providing a password. In particular this is true for the workflow service. In this case, logging in another session might be as simple as:</p><p class="p--codeblock">User user = ...;<br/>CapSession session = connection.login(user);</p><p>Note that it is not possible for ordinary user code to create a privileged connection. Instead, a privileged connection is returned by framework methods like <span class="inlineformat--code">WfServer.getConnection()</span>.</p><p/></div><div xmlns="http://www.coremedia.com/2003/richtext-1.0" xmlns:xlink="http://www.w3.org/1999/xlink"><p>When writing properties of a <span class="inlineformat--code">CapObject</span>, these writes are initially buffered and not sent to a server. Afterwards, the accumulated changes are sent to the server during a <span class="inlineformat--code">flush()</span> call on the session object.</p><p>Writes are buffered per session. If a session is made the current session in more than one thread, all of these threads will share a common write buffer. This means that they can see each other's changes and that one flush call on the session objects will flush all changes at once. </p><p>For this reason it is not normally a good idea to work with more than one thread using one session. The threads will continually lock out each other as the <em>Unified API</em> synchronizes for accessing the write buffer, leading to reduced performance. It is advisable to use one session per thread in a multi-threaded environment. You might even want to log in multiple times with the same user in this case.</p><p>The write buffers are also flushed when a call is made that cannot be handled locally by the <em>Unified API</em>. Currently, all calls except setters and getters will flush the write buffers, but this may change in future versions.</p><p>It is a good practice to flush the write buffers before any user interaction is resumed, before long delays are expected, and before returning from public methods that may be called from arbitrary code.</p></div>