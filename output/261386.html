<div xmlns="http://www.coremedia.com/2003/richtext-1.0" xmlns:xlink="http://www.w3.org/1999/xlink"><p>In this section, we compiled a couple of SSE query examples which cover some typical use cases.</p><p class="p--heading-2">Retrieve ratings for some given user generated content</p><p class="p--codeblock">final RelationshipBeanCriteria relationshipCriteria = <br/>  baseModule.getRelationshipBeanCriteria();<br/>RelationshipType starRatingType = <br/>  baseModule.getRepository().getRelationshipType("StarRating");<br/>List&lt;Rating&gt; ratings = (List&lt;Rating&gt;)   <br/>  baseModule.createQuery(starRatingType)<br/>    .where(relationshipCriteria.roleValueIs(<br/>      baseModule.getRatingType().getTargetRole(), <br/>      userContent))<br/>    .list();</p><p>Here, we assume that a relationship type <span class="inlineformat--code">StarRating</span> is defined by inheriting from the relationship type <span class="inlineformat--code">Rating </span>defined in the base module. Retrieved are all elements of this <span class="inlineformat--code">StarRating</span> type which are bound to some given <span class="inlineformat--code">userContent</span> resource by means of the target role (which is inherited from the <span class="inlineformat--code">Rating</span> relationship).</p><p class="p--heading-2">Retrieve the 10 latest answers/comments in a thread in which a specific author participated</p><p class="p--codeblock">UserContentCriteria criteria =<br/>  baseModule.getUserContentCriteria();<br/>User someAuthor = null;<br/>List newestCommentsToAuthorsContent =<br/>  baseModule.createQuery(baseModule.getUserContentType())<br/>    .where(criteria.inSameThreadAsOneOf(<br/>       criteria.authorIs(someAuthor))<br/>       .and(criteria.inRole(<br/>          baseModule.getCommentCommentRole())))<br/>       .orderBy(criteria<br/>       .orderByCreationDate(Order.Direction.DESCENDING))<br/>       .setLimit(10)<br/>       .list();</p><p>This query will also retrieve comments written by <span class="inlineformat--code">someAuthor</span> herself, so you might want to filter these out. In this case, just add another where clause with a negated <span class="inlineformat--code">authorIs()</span> criterion. Recall that the author-relationship is modeled by the relationship <span class="inlineformat--code">Ownership</span> between a <span class="inlineformat--code">User</span> and other resources. </p><p class="p--heading-2">Retrieve the users which have written something recently</p><p class="p--codeblock"> List&lt;User&gt; authors = (List&lt;User&gt;)<br/>   baseModule.createQuery(baseModule.getOwnershipType())<br/>     .where(relationshipCriteria.roleValueTypeIs(<br/>       baseModule.getOwnershipObjectRole(),<br/>       baseModule.getUserContentType()))<br/>     .orderBy(relationshipCriteria<br/>     .orderByCreationDate(Order.Direction.DESCENDING))<br/>     .setProjection(relationshipCriteria<br/>       .toRole(baseModule.getOwnershipOwnerRole()))<br/>     .setLimit(20)<br/>     .list();</p><p class="p--standard">Again, recall that the author-relationship is modeled by the relationship <span class="inlineformat--code">Ownership</span> between a <span class="inlineformat--code">User</span> and other resources. </p><p class="p--heading-2">Compute a tag cloud for the 30 most frequently used tags within the repository</p><p class="p--codeblock"><br/>TaggingCriteria taggingCriteria = baseModule.getTaggingCriteria();<br/>List&lt;KeyValuePair&lt;String, Number&gt;&gt; tagCounts = <br/>  baseModule.createQuery(baseModule.getTaggingType())<br/>    .setProjection(taggingCriteria.countTags(true))<br/>    .setLimit(30)<br/>    .list();<br/>Comparator &lt;KeyValuePair&lt;String, Number&gt;&gt; <br/>  ignoreCaseValueCountComparator = <br/>    new Comparator&lt;KeyValuePair&lt;String, Number&gt;&gt;() {<br/>       public int compare(<br/>          KeyValuePair&lt;String, Number&gt; o1,<br/>          KeyValuePair&lt;String, Number&gt; o2) {<br/>        return o1.getKey().compareToIgnoreCase(o2.getKey());<br/>      }<br/>    };<br/>Collections.sort(tagCounts, ignoreCaseValueCountComparator)</p><p>When setting the <span class="inlineformat--code">countTags()</span> projection, the result list is implicitly ordered by the number of tag occurrences (the value part of the key value pairs). The most frequent tags come first. So, if we want the tags to appear in alphabetical order (modulo upper/lowercase), we have to sort the result list with our own comparator before rendering it on a web page.</p><p class="p--heading-2">Compute a tag cloud for the 50 tags a given user has used</p><p class="p--codeblock">TaggingCriteria taggingCriteria =<br/>   baseModule.getTaggingCriteria();<br/> List&lt;KeyValuePair&lt;String, Number&gt;&gt; tagCounts =<br/>   baseModule.createQuery(baseModule.getTaggingType())<br/>     .where(taggingCriteria.userIs(someUser))<br/>     .setProjection(taggingCriteria.countTags(true))<br/>     .setLimit(50)<br/>     .list();<br/> Collections.sort(tagCounts, ignoreCaseValueCountComparator);</p><p class="p--heading-2">Retrieve user content by a date interval</p><p class="p--codeblock"><span xml:lang="EN-US"> final ResourceType userContentType = baseModule.getUserContentType();</span><br/> final UserContentCriteria criteria = <br/>   new UserContentCriteria(baseModule, userContentType);<br/> baseModule.createQuery(userContentType)<br/>   .where(criteria.modificationDateBetween(from, to))<br/>   .orderBy(criteria.orderByCreationDate(Order.Direction.DESCENDING))<br/>   .setLimit(20).list();</p><p class="p--heading-2">Retrieve the latest post of a given user</p><p class="p--codeblock">List&lt;UserContent&gt; latestPosts = (List&lt;UserContent&gt;) <br/>  baseModule.createQuery(baseModule.getUserContentType())<br/>     .where(criteria.ownerIs(someUser))<br/>     .orderBy(criteria<br/>       .orderByCreationDate(Order.Direction.DESCENDING))<br/>     .setLimit(1)<br/>     .list();<br/>    if (!latestPosts.isEmpty()) {<br/>      UserContent latestPost = (UserContent) latestPosts.get(0);<br/>      ...</p><p class="p--heading-2">Compute a tag cloud for a given time interval</p><p class="p--codeblock"> List&lt;KeyValuePair&lt;String, Number&gt;&gt; tagCounts =<br/>   baseModule.createQuery(baseModule.getTaggingType())<br/>     .where(taggingCriteria.targetIn(<br/>        userContentCriteria.creationDateBetween(from, to)))<br/>     .setProjection(taggingCriteria.countTags(false))<br/>     .setLimit(40)<br/>     .list();</p><p class="p--standard"><span xml:lang="EN-US">As in the example given above, you'll have to sort the result if you want the tags to appear in alphabetical order.</span></p><p class="p--heading-2">Retrieve user content by tag</p><p class="p--codeblock">List&lt;UserContent&gt; userContentByTag = (List&lt;UserContent&gt;)  <br/>  baseModule.createQuery(baseModule.getUserContentType())<br/>   .where(userContentCriteria.taggedWith(DEFAULT_TAG))<br/>   .setLimit(20)<br/>   .list();</p><p class="p--standard"><span xml:lang="EN-US">DEFAULT_TAG is the tag which you like to query.</span></p><p class="p--heading-2">Retrieve users by the time of postings</p><p class="p--codeblock">baseModule.createQuery(baseModule.getOwnershipType())<br/>  .where(relationshipCriteria.roleValueTypeIs(<br/>     baseModule.getOwnershipObjectRole(),<br/>     baseModule.getUserContentType()))<br/>  .where(criteria.creationDateBetween(from, to))<br/>  .orderBy(criteria<br/>  .orderByCreationDate(Order.Direction.DESCENDING))<br/>      .setProjection(relationshipCriteria.toRole(<br/>          baseModule.getOwnershipOwnerRole()))<br/>  .setLimit(10)<br/>  .list();</p><p class="p--heading-2">Tag drilldown - Compute a tag cloud for taggings which contain a given tag</p><p class="p--codeblock">UserContentCriteria userContentCriteria = <br/>  baseModule.getUserContentCriteria();<br/>List&lt;KeyValuePair&lt;String, Number&gt;&gt;  tagCounts = <br/>  baseModule.createQuery(baseModule.getTaggingType())<br/>    .where(taggingCriteria.targetIn(<br/>       userContentCriteria.taggedWithAll(<br/>          Arrays.asList(new String[]{¿web20¿, ¿enterprise¿}))))<br/>    .setProjection(taggingCriteria.countTags(false))<br/>    .setLimit(10)<br/>    .list();</p><p class="p--heading-2">Calculate average rating for some user content</p><p class="p--codeblock"><span xml:lang="EN-US">RatingCriteria ratingCriteria = baseModule.getRatingCriteria();</span><br/><span xml:lang="EN-US">RelationshipType starRatingType =</span><br/> <span xml:lang="EN-US"> baseModule.getRepository().getRelationshipType("StarRating");</span><br/><span xml:lang="EN-US">List&lt;Number&gt; averageRating = (List&lt;Number&gt;)</span><br/> <span xml:lang="EN-US"> baseModule.createQuery (starRatingType)</span><br/> <span xml:lang="EN-US"> </span>  <span xml:lang="EN-US">.where(ratingCriteria.targetIs(userContent))</span><br/>   <span xml:lang="EN-US"> .setProjection(ratingCriteria.averageRating())</span><br/>   <span xml:lang="EN-US"> .list();</span></p><p>This example assumes that a <span class="inlineformat--code">Rating</span> subtype named "StarRating" has been defined. The result will be a singleton list, containing one <span class="inlineformat--code">Numbe</span>r instance.</p><p class="p--heading-2">Calculate a histogram of average ratings for user content</p><p class="p--codeblock"><span xml:lang="EN-US">List&lt;KeyValuePair&lt;Resource, Number&gt;&gt; ratingHistogram =</span><br/>  <span xml:lang="EN-US">(List&lt;KeyValuePair&lt;Resource, Number&gt;&gt;)</span><br/>   <span xml:lang="EN-US"> baseModule.createQuery(starRatingType)</span><br/>     <span xml:lang="EN-US"> .setProjection(ratingCriteria.averageRatingByTarget())</span><br/>     <span xml:lang="EN-US"> .setLimit(20)</span><br/>   <span xml:lang="EN-US"> </span> <span xml:lang="EN-US">.list();</span></p><p>The list will be implicitly ordered by the average rating with the highest rating first. So you can get the 20 top rated content objects by limiting the result.</p><p class="p--heading-2">Retrieve the authors of content which is rated high</p><p class="p--codeblock">List&lt;KeyValuePair&lt;Resource, Number&gt;&gt; ratingHistogram =<br/>  (List&lt;KeyValuePair&lt;Resource, Number&gt;&gt;) <br/>    baseModule.createQuery(starRatingType)<br/>     .setProjection(ratingCriteria.averageRatingByTarget())<br/>     .setLimit(20)<br/>     .list();<br/>Set&lt;User&gt; authors = new HashSet&lt;User&gt;();<br/>for (KeyValuePair&lt;Resource, Number&gt; pair: ratingHistogram) {<br/>      Object bean = elementBeanFactory<br/>                    .createBeanFor(pair.getKey());<br/>      if (bean instanceof UserContent) {<br/>        UserContent userContent = (UserContent) bean;<br/>        authors.add(userContent.getAuthor());<br/>      }<br/>      // else fetch the "author" depending on bean type...<br/>    }</p><p>The size of the query result list is limited here to 20. Due to duplicate authors, the result set of authors may actually be smaller than 20 even if 20 or more <span class="inlineformat--code">UserContent</span> objects are found within the repository.</p><p class="p--heading-2">Calculate a histogram of votings</p><p class="p--codeblock"><span xml:lang="EN-US">List&lt;KeyValuePair&lt;Integer, Number&gt;&gt; histogram =</span><br/><span xml:lang="EN-US"> </span>      <span xml:lang="EN-US"> baseModule.createQuery(helpfulnessType)</span><br/>           <span xml:lang="EN-US"> .setProjection(votingCriteria.countChoices())</span><br/>           <span xml:lang="EN-US"> .list();</span></p><p>This query gathers the occurrence counts of each different choice, assuming there is a voting subtype ¿helpfulness¿ defined. That is, it maps each different choice which occurs at least once within the repository (the key part of the KeyValuePair, an Integer value) to the number of occurrences (the value part, a Number instance).</p><p class="p--heading-2">Calculate a histogram of votings for a specific object</p><p class="p--codeblock">List&lt;KeyValuePair&lt;Integer, Number&gt;&gt;  histogram = <br/>       baseModule.createQuery(helpfulnessType)<br/>            .where(votingCriteria.targetIs(userContent))<br/>            .setProjection(votingCriteria.countChoices())<br/>            .list();</p><p class="p--heading-2">Calculate of histogram of total voting counts for a given choice</p><p class="p--codeblock">List&lt;KeyValuePair&lt;Resource, Number&gt;&gt; histogram2 = <br/>   baseModule.createQuery(helpfulnessType)<br/>            .where(votingCriteria.choiceIs(2))<br/>            .setProjection(votingCriteria.countVotings())<br/>            .setLimit(20)<br/>            .list();</p><p>This query gathers the total number of votings, grouped by target resource. This query limits the size of the query result to 20 resource-count mapping pairs.</p><p class="p--heading-2">Retrieve user content readable to some specific user</p><p class="p--codeblock">  User someUser = null;<br/>  List&lt;Subject&gt; subjects = new ArrayList&lt;Subject&gt;();<br/>  subjects.addAll(someUser.getGroups());<br/>  List&lt;UserContent&gt; result =<br/>    baseModule.createQuery(baseModule.getUserContentType())<br/>      .where(baseModule.getUserContentCriteria()<br/>        .readRightsFor(subjects))<br/>      .setLimit(30)<br/>      .list();</p><p>This example assumes that ACL entries are attached directly to the content objects. To reduce the total number of ACL entries which have to be created within the repository, an alternative would be to attach the ACL entries to some container object such as a blog. Note that the readRightsFor criterion does not take group membership into account. This logic is left to the application level. This means that each group the user is in has to be added explicitly to the subject set (assuming group membership implies rights inheritance), as well as the user (assuming user-level ACL entries are used within the application).</p><p class="p--heading-2">Count the number of posts of a given user</p><p class="p--codeblock">  final UserContentCriteria userContentCriteria = <br/>new UserContentCriteria(baseModule, baseModule.getUserContentType());<br/>  List&lt;Number&gt; counts = (List&lt;Number&gt;)<br/>    baseModule.createQuery(baseModule.getUserContentType())<br/>      .where(userContentCriteria.ownerIs(user1))<br/>      .setProjection(userContentCriteria.count())<br/>      .list();<br/>  int count = counts.get(0).intValue();</p><p class="p--heading-2">Retrieve the latest approved posts</p><p class="p--codeblock">List&lt;UserContent&gt; result = (List&lt;UserContent&gt;)<br/>    baseModule.createQuery(baseModule.getUserContentType())<br/>      .where(userContentCriteria.inRole(<br/>        baseModule.getClassificationTargetRole(),<br/>        baseModule.getVotingCriteria().typeIs(baseModule.<br/>          getApprovalType())))<br/>      .orderBy(userContentCriteria.orderByCreationDate(<br/>        Order.Direction.DESCENDING))<br/>      .setLimit(30)<br/>      .list(); </p><p>A post is considered approved if there exists an <span class="inlineformat--code">Approval</span> relationship with the post in the target role. This example uses the <span class="inlineformat--code">inRole</span> criterion <span xml:lang="EN-GB">to find the </span><span class="inlineformat--code" xml:lang="EN-GB">Approval</span><span xml:lang="EN-GB"> relationships</span>. </p><p class="p--heading-2">Retrieve the latest approved posts (2)</p><p class="p--codeblock">  List&lt;UserContent&gt; result = (List&lt;UserContent&gt;)<br/>    baseModule.createQuery(baseModule.getUserContentType())<br/>      .where(userContentCriteria.relatedToAny(<br/>        baseModule.getClassificationUserRole(),<br/>        baseModule.getApprovalType()))<br/>      .orderBy(userContentCriteria.orderByCreationDate(<br/>        Order.Direction.DESCENDING))<br/>      .setLimit(30)<br/>      .list();</p><p><span xml:lang="EN-GB">This query is equivalent to the previous example query but uses a different criterion to find the </span><span class="inlineformat--code" xml:lang="EN-GB">Approval</span><span xml:lang="EN-GB"> relationships: </span>the <span class="inlineformat--code">relatedToAny</span> criterion. </p><p/></div>