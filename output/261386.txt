

In this section, we compiled a couple of SSE query examples which cover some typical use cases.

Retrieve ratings for some given user generated content

final RelationshipBeanCriteria relationshipCriteria = 
  baseModule.getRelationshipBeanCriteria();
RelationshipType starRatingType = 
  baseModule.getRepository().getRelationshipType("StarRating");
List<Rating> ratings = (List<Rating>)   
  baseModule.createQuery(starRatingType)
    .where(relationshipCriteria.roleValueIs(
      baseModule.getRatingType().getTargetRole(), 
      userContent))
    .list();

Here, we assume that a relationship type StarRating is defined by inheriting from the relationship type Rating defined in the base module. Retrieved are all elements of this StarRating type which are bound to some given userContent resource by means of the target role (which is inherited from the Rating relationship).

Retrieve the 10 latest answers/comments in a thread in which a specific author participated

UserContentCriteria criteria =
  baseModule.getUserContentCriteria();
User someAuthor = null;
List newestCommentsToAuthorsContent =
  baseModule.createQuery(baseModule.getUserContentType())
    .where(criteria.inSameThreadAsOneOf(
       criteria.authorIs(someAuthor))
       .and(criteria.inRole(
          baseModule.getCommentCommentRole())))
       .orderBy(criteria
       .orderByCreationDate(Order.Direction.DESCENDING))
       .setLimit(10)
       .list();

This query will also retrieve comments written by someAuthor herself, so you might want to filter these out. In this case, just add another where clause with a negated authorIs() criterion. Recall that the author-relationship is modeled by the relationship Ownership between a User and other resources. 

Retrieve the users which have written something recently

 List<User> authors = (List<User>)
   baseModule.createQuery(baseModule.getOwnershipType())
     .where(relationshipCriteria.roleValueTypeIs(
       baseModule.getOwnershipObjectRole(),
       baseModule.getUserContentType()))
     .orderBy(relationshipCriteria
     .orderByCreationDate(Order.Direction.DESCENDING))
     .setProjection(relationshipCriteria
       .toRole(baseModule.getOwnershipOwnerRole()))
     .setLimit(20)
     .list();

Again, recall that the author-relationship is modeled by the relationship Ownership between a User and other resources. 

Compute a tag cloud for the 30 most frequently used tags within the repository


TaggingCriteria taggingCriteria = baseModule.getTaggingCriteria();
List<KeyValuePair<String, Number>> tagCounts = 
  baseModule.createQuery(baseModule.getTaggingType())
    .setProjection(taggingCriteria.countTags(true))
    .setLimit(30)
    .list();
Comparator <KeyValuePair<String, Number>> 
  ignoreCaseValueCountComparator = 
    new Comparator<KeyValuePair<String, Number>>() {
       public int compare(
          KeyValuePair<String, Number> o1,
          KeyValuePair<String, Number> o2) {
        return o1.getKey().compareToIgnoreCase(o2.getKey());
      }
    };
Collections.sort(tagCounts, ignoreCaseValueCountComparator)

When setting the countTags() projection, the result list is implicitly ordered by the number of tag occurrences (the value part of the key value pairs). The most frequent tags come first. So, if we want the tags to appear in alphabetical order (modulo upper/lowercase), we have to sort the result list with our own comparator before rendering it on a web page.

Compute a tag cloud for the 50 tags a given user has used

TaggingCriteria taggingCriteria =
   baseModule.getTaggingCriteria();
 List<KeyValuePair<String, Number>> tagCounts =
   baseModule.createQuery(baseModule.getTaggingType())
     .where(taggingCriteria.userIs(someUser))
     .setProjection(taggingCriteria.countTags(true))
     .setLimit(50)
     .list();
 Collections.sort(tagCounts, ignoreCaseValueCountComparator);

Retrieve user content by a date interval

 final ResourceType userContentType = baseModule.getUserContentType();
 final UserContentCriteria criteria = 
   new UserContentCriteria(baseModule, userContentType);
 baseModule.createQuery(userContentType)
   .where(criteria.modificationDateBetween(from, to))
   .orderBy(criteria.orderByCreationDate(Order.Direction.DESCENDING))
   .setLimit(20).list();

Retrieve the latest post of a given user

List<UserContent> latestPosts = (List<UserContent>) 
  baseModule.createQuery(baseModule.getUserContentType())
     .where(criteria.ownerIs(someUser))
     .orderBy(criteria
       .orderByCreationDate(Order.Direction.DESCENDING))
     .setLimit(1)
     .list();
    if (!latestPosts.isEmpty()) {
      UserContent latestPost = (UserContent) latestPosts.get(0);
      ...

Compute a tag cloud for a given time interval

 List<KeyValuePair<String, Number>> tagCounts =
   baseModule.createQuery(baseModule.getTaggingType())
     .where(taggingCriteria.targetIn(
        userContentCriteria.creationDateBetween(from, to)))
     .setProjection(taggingCriteria.countTags(false))
     .setLimit(40)
     .list();

As in the example given above, you'll have to sort the result if you want the tags to appear in alphabetical order.

Retrieve user content by tag

List<UserContent> userContentByTag = (List<UserContent>)  
  baseModule.createQuery(baseModule.getUserContentType())
   .where(userContentCriteria.taggedWith(DEFAULT_TAG))
   .setLimit(20)
   .list();

DEFAULT_TAG is the tag which you like to query.

Retrieve users by the time of postings

baseModule.createQuery(baseModule.getOwnershipType())
  .where(relationshipCriteria.roleValueTypeIs(
     baseModule.getOwnershipObjectRole(),
     baseModule.getUserContentType()))
  .where(criteria.creationDateBetween(from, to))
  .orderBy(criteria
  .orderByCreationDate(Order.Direction.DESCENDING))
      .setProjection(relationshipCriteria.toRole(
          baseModule.getOwnershipOwnerRole()))
  .setLimit(10)
  .list();

Tag drilldown - Compute a tag cloud for taggings which contain a given tag

UserContentCriteria userContentCriteria = 
  baseModule.getUserContentCriteria();
List<KeyValuePair<String, Number>>  tagCounts = 
  baseModule.createQuery(baseModule.getTaggingType())
    .where(taggingCriteria.targetIn(
       userContentCriteria.taggedWithAll(
          Arrays.asList(new String[]{¿web20¿, ¿enterprise¿}))))
    .setProjection(taggingCriteria.countTags(false))
    .setLimit(10)
    .list();

Calculate average rating for some user content

RatingCriteria ratingCriteria = baseModule.getRatingCriteria();
RelationshipType starRatingType =
  baseModule.getRepository().getRelationshipType("StarRating");
List<Number> averageRating = (List<Number>)
  baseModule.createQuery (starRatingType)
    .where(ratingCriteria.targetIs(userContent))
    .setProjection(ratingCriteria.averageRating())
    .list();

This example assumes that a Rating subtype named "StarRating" has been defined. The result will be a singleton list, containing one Number instance.

Calculate a histogram of average ratings for user content

List<KeyValuePair<Resource, Number>> ratingHistogram =
  (List<KeyValuePair<Resource, Number>>)
    baseModule.createQuery(starRatingType)
      .setProjection(ratingCriteria.averageRatingByTarget())
      .setLimit(20)
     .list();

The list will be implicitly ordered by the average rating with the highest rating first. So you can get the 20 top rated content objects by limiting the result.

Retrieve the authors of content which is rated high

List<KeyValuePair<Resource, Number>> ratingHistogram =
  (List<KeyValuePair<Resource, Number>>) 
    baseModule.createQuery(starRatingType)
     .setProjection(ratingCriteria.averageRatingByTarget())
     .setLimit(20)
     .list();
Set<User> authors = new HashSet<User>();
for (KeyValuePair<Resource, Number> pair: ratingHistogram) {
      Object bean = elementBeanFactory
                    .createBeanFor(pair.getKey());
      if (bean instanceof UserContent) {
        UserContent userContent = (UserContent) bean;
        authors.add(userContent.getAuthor());
      }
      // else fetch the "author" depending on bean type...
    }

The size of the query result list is limited here to 20. Due to duplicate authors, the result set of authors may actually be smaller than 20 even if 20 or more UserContent objects are found within the repository.

Calculate a histogram of votings

List<KeyValuePair<Integer, Number>> histogram =
        baseModule.createQuery(helpfulnessType)
            .setProjection(votingCriteria.countChoices())
            .list();

This query gathers the occurrence counts of each different choice, assuming there is a voting subtype ¿helpfulness¿ defined. That is, it maps each different choice which occurs at least once within the repository (the key part of the KeyValuePair, an Integer value) to the number of occurrences (the value part, a Number instance).

Calculate a histogram of votings for a specific object

List<KeyValuePair<Integer, Number>>  histogram = 
       baseModule.createQuery(helpfulnessType)
            .where(votingCriteria.targetIs(userContent))
            .setProjection(votingCriteria.countChoices())
            .list();

Calculate of histogram of total voting counts for a given choice

List<KeyValuePair<Resource, Number>> histogram2 = 
   baseModule.createQuery(helpfulnessType)
            .where(votingCriteria.choiceIs(2))
            .setProjection(votingCriteria.countVotings())
            .setLimit(20)
            .list();

This query gathers the total number of votings, grouped by target resource. This query limits the size of the query result to 20 resource-count mapping pairs.

Retrieve user content readable to some specific user

  User someUser = null;
  List<Subject> subjects = new ArrayList<Subject>();
  subjects.addAll(someUser.getGroups());
  List<UserContent> result =
    baseModule.createQuery(baseModule.getUserContentType())
      .where(baseModule.getUserContentCriteria()
        .readRightsFor(subjects))
      .setLimit(30)
      .list();

This example assumes that ACL entries are attached directly to the content objects. To reduce the total number of ACL entries which have to be created within the repository, an alternative would be to attach the ACL entries to some container object such as a blog. Note that the readRightsFor criterion does not take group membership into account. This logic is left to the application level. This means that each group the user is in has to be added explicitly to the subject set (assuming group membership implies rights inheritance), as well as the user (assuming user-level ACL entries are used within the application).

Count the number of posts of a given user

  final UserContentCriteria userContentCriteria = 
new UserContentCriteria(baseModule, baseModule.getUserContentType());
  List<Number> counts = (List<Number>)
    baseModule.createQuery(baseModule.getUserContentType())
      .where(userContentCriteria.ownerIs(user1))
      .setProjection(userContentCriteria.count())
      .list();
  int count = counts.get(0).intValue();

Retrieve the latest approved posts

List<UserContent> result = (List<UserContent>)
    baseModule.createQuery(baseModule.getUserContentType())
      .where(userContentCriteria.inRole(
        baseModule.getClassificationTargetRole(),
        baseModule.getVotingCriteria().typeIs(baseModule.
          getApprovalType())))
      .orderBy(userContentCriteria.orderByCreationDate(
        Order.Direction.DESCENDING))
      .setLimit(30)
      .list(); 

A post is considered approved if there exists an Approval relationship with the post in the target role. This example uses the inRole criterion to find the Approval relationships. 

Retrieve the latest approved posts (2)

  List<UserContent> result = (List<UserContent>)
    baseModule.createQuery(baseModule.getUserContentType())
      .where(userContentCriteria.relatedToAny(
        baseModule.getClassificationUserRole(),
        baseModule.getApprovalType()))
      .orderBy(userContentCriteria.orderByCreationDate(
        Order.Direction.DESCENDING))
      .setLimit(30)
      .list();

This query is equivalent to the previous example query but uses a different criterion to find the Approval relationships: the relatedToAny criterion. 

