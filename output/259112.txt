

Using Projections

A Projection represents a mapping of the items within a query result list to some values derived from these items. Examples of possible mappings include the selection of some component property of the items, and aggregate computations such as counting the total number of items, summing up the property values or calculating their average value.  

Projection instances are, like Criterion objects, created by using a domain specific criteria factory where you have to specify the exact kind of mapping which should be applied. As an example, the following projection simply counts the size of the result set, which is the number of content objects submitted by a given user. This projection saves the overhead of fetching all content objects from the database in order to determine this number:

List<Number> counts = (List<Number>) 
   baseModule.createQuery(baseModule.getUserContentType())
            .where(userContentCriteria.ownerIs(user1))
            .setProjection(userContentCriteria.count())
            .list();
int count = counts.get(0).intValue();

A more interesting (and complex) kind of projections are histogram projections which return a list of key value pairs. These contain a computed value for some group of items within the result set. This is similar to the functionality provided by GROUP BY and aggregate expressions in SQL. As an example, the following query computes a tag cloud for the 30 most frequently used tags within the repository: 

TaggingCriteria taggingCriteria = baseModule.getTaggingCriteria();
List<KeyValuePair<String, Number>> tagCounts = 
  baseModule.createQuery(baseModule.getTaggingType())
    .setProjection(taggingCriteria.countTags(true))
    .setLimit(100)
    .list();


Note that, when setting the countTags() projection, the result list is implicitly ordered by the number of tag occurrences (the value part of the key value pair), most frequent tags first.