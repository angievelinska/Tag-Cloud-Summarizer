

There are three main Page JSP-files to start with:

Page: Renders ordinary content. 
Page.asSitemap: Renders the content's navigation context as a partial sitemap. 
Page.asSearchResult: Renders a search result which is not backed by a content bean but executes a query with the search terms provided in the URL parameter "q". 

These pages are only necessary to match the view dispatcher naming conventions. They all delegate to Page.yaml, passing their view as request attribute "mainView". Page.yaml provides the <html> frame with the yaml class attributes and includes Page.yamlHeader, Page.yamlMain and Page.yamlFooter to render the subsections. These yaml section JSP-files render further YAML annotated structures (especially Page.yamlMain creates the three-column-layout) and finally include the content- or navigation-specific JSP-files which work on ordinary content beans.

Normally the content bean backed JSP-files should not need to know about their context. However, in case you need any Page data even in those very depths, you can access the Page object by the request attribute cmpage (SegmentViewController.ATTR_NAME_PAGE).

There are two Page JSP-files not yet mentioned: Page.head.jsp renders the <head> data like keywords, CSS inclusions and the like. It is not a top level structural template, but it needs data from both, content and navigation beans and is therefore implemented as a Page JSP. Page.asData.jsp is another entry JSP-file which however does not delegate to Page.yaml like the others, but ignores the context and only includes the content with view "asData". A usecase for Page.asData is the rendering of a CMHTML document (CMHTML.jsp): The html BLOB of the document is rendered in an <iframe>, and for the src attribute we need a URL (and thus a top level entry JSP) which serves exactly the html BLOB from the document without any wrapping generated by the standard Page mechanism.

Views

The JSP-files which are backed by ordinary content beans follow the usual CAE naming pattern "BeanInterface.view.jsp" which is supported by the view dispatcher. For the view part the Starter Kit introduces some more detailed naming conventions. 

JSP-files without a view name (e.g. CMArticle.jsp) render their objects full sized and detailed. There are JSPs for nearly each concrete document type from the starterkit-standard-doctypes declaration. 
"asTeaser" JSPs render a small view of their content bean. Omitting the details allows for a generic JSP CMTeasable.asTeaser.jsp which renders only properties of the abstract CMTeasable interface. There are special asTeaser JSPs only for CMDownload and CMExternalLink which are rendered yet more compact than default teasers. 

"asLink" JSPs render a link to their particular content. There is a generic CMLinkable.asLink.jsp and some special variants. CMTeasable.asLink.jsp renders a link with the CMTeasable's own linktext but a reference to its target instead of itself. This makes a difference for standalone Teasers (CMTeaser documents). CMDownload.asLink.jsp references the particular blob property instead of the document itself. CMExternalLink.asLink.jsp renders an ordinary <a> instead of an analytics link, links to the specified URL and sets the _blank target value to open in a new tab or window. 
"asFooter", "asHeader" and "asTopNavigation" are invoked by Page.yamlFooter and Page.yamlHeader, respectively. Since our sample Page JSPs only render the navigation as header and footer, there are only implementations for CMChannel. If you change the Page templates and put content into the header or footer, you will have to write additional JSPs. 
"asFooterItem" and "asHeaderItem" are invoked from the CMChannel templates to render content in the YAML footer or header section. The default CMLinkable templates simply delegate to the "asLink" templates. 

There are some more templates which are not explained  here in detail. Just notice the naming convention: "asSomething" views render the object as a whole somehow (link, teaser, detailed, ...), and they are often applicable for different purposes. Other views like "submenu" or "sitemapRecursive" are really special and probably not useful if you change or write new JSPs. 

Viewtypes

The entry template and thus the overall layout of a page is determined by the URL parameter "view" (standard CoreMedia CAE). However, you might want certain contexts or contents to be rendered in a particular manner. The Starter Kit sample sites make use of CMAction documents to represent sitemaps and searches. CMAction documents are quite rare in comparison to ordinary content, and rendering them (e.g. as a search field) does not make use of a lot of properties in many cases.  So you don't want to declare an extra doctype for each kind of action.  Instead, you can simply use the CMAction content type, attach a so called viewtype to each action document and provide a specialized JSP for the viewtype. 

The Starter Kit enhances the default template selection mechanism of the CoreMedia CAE and considers the viewtypes to choose specialized templates.

The Page implementation determines the content and channel from the URL, and since channels are hierarchical, the channel has a root channel. Each of these three documents can have a viewtype assignment. The ViewDispatcher uses the viewtypes to construct the filename of the potential template. The viewtype triplet is appended to the view name in square brackets, with the root, channel, and content viewtypes separated by commas. If a template should apply to more than one combination of viewtypes, it is possible to replace the viewtype name with "_" as a wildcard. (Esp. the wildcard matches if the root, channel or content has no viewtype.) The viewtypes are searched in the following order ("+" means that the document has a viewtype):