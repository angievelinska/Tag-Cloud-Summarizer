

Mapping state model variables to data model dimensions

In order to decouple state and data model, variable aspect names are mapped to dimension constraint names in the data model. All data model-level components, as well as queries, aggregator and postprocessor, use the dimension constraint names.

You define this mapping with the data model¿s `dimConstraintMappings¿ map property. The mapping function maps data model dimension constraint names to state model aspect names, the latter written as variablename `.¿ aspectname. A mapping example:

<property name="dimConstraintMappings">
  <map>
    <entry key="range" value="rangeVariable.rangeConstraint"/>
    <entry key="resolution" 
     value="rangeVariable.dependentResolutionConstraint"/>
  </map>
</property>

In the example, the state model variable `rangeVariable¿ defines two aspects: a `rangeConstraint¿, which is a dimension range, and a `dependentResolutionConstraint¿, which is a dimension discretizer. The range dimension constraint is named 'range' in the data model, while the resolution constraint is named `resolution¿.

Declarative and programmatic access to dimension constraints

Data models provide generic access to dimension constraints for declarative, `configuration-only¿ report definition. Any datamodel dimension constraint can be accessed using the data model's dimConstraint() method with the dimension constraint name as parameter. Example:

...
ReportDataModel dataModel = ...
DimensionConstraint dc = dimConstraint("resolution");
...

will return the dimension constraint named `resolution¿.

If you require statically-typed access to dimension constraints, create a Java class for your data model with accessors (getter methods) to dimension constraints. In general you will not need specific Java classes for data model. When creating a larger number of reports, we recommend sticking to generic access.

