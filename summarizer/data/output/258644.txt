

Internal details

Internally, a <httpcache:include>-tag and its <httpcache:param>- and <httpcache:header>-tags will be transformed into an com.coremedia.cap.httpcache.Request object. This is done, transforming the bean/view-pair into a URI using a link scheme. Based on the Request-object and the cacheableRequestPredicate, the Http Cache distinguishes between static/cacheable and dynamic fragments.

If it is a static fragment:

The headers and parameters passed to the fragment and filtered by the requestNormalizer are included in the CacheKey.
The headers and parameters passed to the fragment and filtered by the requestNormalizer are the only ones, which are visible in the jsp-template.

If it is a dynamic fragment:

The headers and parameters passed to the fragment are not filtered. They are combined with the headers and parameters of the root request and are visible in the jsp-template.

Guidelines for the use of fragments

Including fragments in jsp-templates is very similar to the standard programming paradigm of the  Content Application Engine - a bean "self" is passed to the jsp-template. Nevertheless, there are some subtleties you should keep in mind:

Do not use request or session attributes in static fragments. Technically it is possible, but it leads to inconsistencies. Given, that such an attribute changes while caching a fragment, this change does not apply, when you retrieve the fragment later from cache.
In the embedded assembly mode you can enrich links in static fragments with session information (with HttpServletResponse#encodeURL(...) for example). In the cache, this information is stored as a placeholder, which is replaced by the current session ID during assembly. So you can prevent a user who has disabled cookies, from leaving his session.    
 Dependencies, that are set explicitly or implicitly during execution of the jsp-template (with com.coremedia.cache.Cache#dependencyOn(...) for example) are stored as dependencies of this fragment if the fragment is cached.
The headers and parameters that are accessible via the HttpServletRequest object (with HttpServletRequest#getHeaderNames() for example) depend on the headers and parameters passed to the template via <httpcache:param> and <httpcache:header> for example.


Depending on the assembly mode you use, the response status and response headers are treated differently for a non-root fragment. So take care when developing templates, how the headers interact. 

Embedded assembly mode: Only status and header of the root fragment are delivered, for sub fragments they are ignored. This implies, for example, that a "time-to-live" set in the "Expires" header of the root fragment is valid for the whole page, hold in the cache. If a sub-fragment has a shorter "time-to-live", this shorter setting might be ignored. In conclusion, the sub-fragment is displayed for longer than its life-time.
Client-side assembly modes: The meta information of all fragments is used.
A cache access always implies a specific overhead. So, only use <httpcache:include> when it makes sense and brings an advantage to include a fragment. Do not use it as a means of template structuring. For this purpose use <cm:include>. 
If you use the AHAH assembly mode, you have to include the corresponding Javascript library into each relevant page, for example:

<%@ page contentType="text/html;charset=utf-8"  session="false" %> 
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"> 
<html> 
  <head> 
    <title>...</title> 
    <!-- Import the AHAH JavaScript Library --> 
    <script language="JavaScript" type="text/javascript" 
    src="<c:url value='/libjs/libjs.js'/>"></script> 
    <script language="JavaScript" type="text/javascript"> 
      loadPackage("com.coremedia.httpcache.ahah", 
      "<c:url value='/libjs' />"); 
    </script> 
    <script language="JavaScript" type="text/javascript"> 
      new com.coremedia.httpcache.ahah.FragmentLoader().register(); 
    </script> 
  </head> 
  <body> 
   ... 
  </body> 
</html> 

Example

This example shows you how to add fragment caching to your standard CAE applications. It demonstrates how beans, controllers, link schemes and templates might work together. Be aware, that this example is intended as a draft. It is only a starting point for your own improved solutions.

It is assumed that the HTML-pages to deliver, consist of multiple content beans. This beans are representations of the single fragments, such as "Navigation", "Login", "Teaser" and the like. For each fragment (i.e. bean) you can determine whether it is static or dynamic. 

Beans

You need to be able, to determine whether a bean is a representation of a static or dynamic fragment. To this end, you might introduce a marker interface or model your content in an appropriate way. 

In this example, the document model contains an abstract document type named "Dynamic", which represents dynamic content. Therefore, all content beans representing dynamic content implement the Dynamic interface. So, you simply have to check, if a content bean implements this interface and if so, it is a dynamic bean.

Link Schemes

You have to extend the link schemes in such a way, that the distinction between static and dynamic fragments is reflected in the created URIs. Each fragment has to be covered by the link scheme and therefore be represented by a URI. This is in contrast to standard CAE applications, where only the root fragment needs to be addressed by a URI.

In the example, the ContentLinkScheme will be extended in the following way:

public DynamicContentLinkScheme extends ContentLinkScheme { 
 
  String formatLink(Object bean, String view, 
  HttpServletRequest request, 
  HttpServletResponse response, boolean forRedirect) 
  throws URISyntaxException { 
    if( bean instanceof Dynamic) { 
      // format the link with the configured prefix 
      super.formatLink(bean, view, request, response, forRedirect); 
    } 
    else { 
      // not responsible. Let next LinkScheme handle this. 
      return null;   
    }      
  } 
} 

Configure the link scheme in your project specific <myComponent>-linkschemes.xml as follows and make sure that they are registered at the linkSchemes bean:

<bean id="staticContentLinkScheme" 
  class="com.coremedia.objectserver.web.links.ContentLinkScheme"> 
  <property name="prefix" value="/static"/> 
  ... 
</bean> 
 
<bean id="dynamicContentLinkScheme" 
      class="com.mycompany.ApplicationContentLinkScheme"> 
  <property name="prefix" value="/dynamic"/> 
  ... 
</bean> 



Controllers

You have to extend the controllers in such a way, that for each URI generated by the link schemes, exist an appropriate controller, that handles the fragment. As for the link schemes, not only the root-fragment but all sub-fragments need to be handled. 

In the example, you simply have to configure one controller in your project specific <myComponente>-controllers.xml-file to handle all URIs.

<bean id="dynamicContentViewController" 
      class="com.coremedia.objectserver.web.ContentViewController">
  <property name="prefix" value="/dynamic"/>
  ...
</bean>

...

<bean id="staticContentViewController"
      class="com.coremedia.objectserver.web.ContentViewController">
  <property name="prefix" value="/static"/>
  ...
</bean>

...

<bean class="org.springframework.web.servlet.handler.
      SimpleUrlHandlerMapping"> 
  <property name="mappings"> 
    <value> 
      /static/*=staticContentViewController 
      /dynamic/*=dynamicContentViewController 
      ... 
    </value> 
  </property> 
</bean>   
... 

jsp-Templates

In the jsp-templates you need a <httpcache:include>-tag for each included fragment. Only use this tag if it is necessary for caching. For example, if you switch from a static to a dynamic fragment or vice versa. In other cases you are better of with the <cm:include self="${bean}"/>-tag.

Cacheable Request Predicate

In a final step, you have to adapt the cacheable request predicate,  so that the distinction between static and dynamics fragments can be made using the URI. In this example, the UriRegexpRequestPredicate has been used and configured in the spring/httpcache/httpcache-hooks-example.xml file:

... 
<bean id="cacheableRequestPredicate" 
      class="com.coremedia.cap.httpcache.UriRegexpRequestPredicate"> 
  <property name="acceptPatterns"> 
    <list> 
      <value>/servlet/static/*</value> 
    </list> 
  </property> 
 
  <property name="rejectPatterns"> 
    <list> 
      <value>/servlet/dynamic/*</value> 
    </list> 
  </property> 
</bean> 
... 