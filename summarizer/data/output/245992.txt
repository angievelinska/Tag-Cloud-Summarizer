

There are three primitive document property types, which are treated similar by ES4JSF: String, integer, and date properties. This section develops meta templates for the corresponding property editors, starting with a simple approach and adding more features (and thus, a bit more complexity) later.

Defining a Simple String Property Editor

The simplest types of properties, String properties, also have the simplest property editor template:

<es:label
  value="#{document.type.descriptorsByName.
         ${property.Name}}"/>
<h:inputText
  value="#{document.properties.${property.Name}}"
  maxlength="${property.Length}"

  disabled="#{!(document.checkedOutByCurrentSession)}"/>

The first component renders the label, together with an icon and a tool tip. The second component is the actual editor component. For a simple property editor, a plain text input field suffices.

The <es:label> component renders a localized label for the CAP property descriptor retrieved by #{document.type.descriptorsByName.${property.Name}}. The corresponding localization keys that have to be defined in your own resource bundle (<BundleName>_<Locale>.properties files) are:

ContentType.${docType.Name}.${property.Name}.text
ContentType.${docType.Name}.${property.Name}.toolTip

The icon is derived from the property type, in this case String.

The <h:inputText> component renders an HTML input element with type="text". The maxlength is set to the maximum number of characters defined in the document property definition. The value attribute references the actual Document property, where "document" is defined in Spring as an editable proxy of the current CoreMedia document (Content). The input field must be disabled in case the document is not checked out by the current user. This restriction can be omitted, since ES4JSF allows auto-checkout of checked-in properties, but this usage is not recommended. Only a successful check-out of the document by the current user guarantees that his changes can be saved later on and will not overwrite other user's changes. Auto-checkout (in combination with auto-checkin) creates a new version even for minor changes, and it may fail in case the document is checked out by another user or the current user does not have sufficient rights to check out the document.

As an example for a concrete String property editor, take the definition of property ingredients of document type Dish in properties/corem/menu-doctype.xml:

<DocType Name="Dish" Parent="Document">
  ...
  <StringProperty Name="ingredients" Length="200"/>
  ...
</DocType>

The instantiation of the simple meta String property editor template given above looks like this:

<es:label
    value="#{document.type.descriptorsByName.ingredients}"/>
<h:inputText
    id="ingredientsEditor"
    value="#{document.properties.ingredients}"
    maxlength="200"
    disabled="#{!(document.checkedOutByCurrentSession)}"/>

The following resource bundle fragment would be used e.g. for german localization of the property label:

ContentType.Dish.ingredients.text=Zutaten
ContentType.Dish.ingredients.toolTip=Alle Zutaten 
für diese Gericht

The template then produces a HTML fragment like the following:

<span class="PropertyType-STRING-icon CMIcon"
      title="Alle Zutaten für diese Gericht">Zutaten
                  </span>
<input id="documentForm:Dish:ingredientsEditor"
       type="text"
       name="documentForm:Dish:ingredientsEditor"
       class="CMInputField"
       value="Mutton, foie gras, caramelized apples, 
             potatoes"
       maxlength="200" />

Although no style classes are given in the JSF view, some class attributes appear in the HTML output. The reason for this behavior is that ES4JSF allows global configuration of style classes per component through Spring (see beandoc of file framework/jsf/editing-jsf.xml). For some components, style classes from the CoreMedia Software Style (files css/coremedia-style*.css) are predefined to ease implementation of the CoreMedia look & feel. However, it is not possible to predefine all style classes, since some components are used in different contexts with different styles. The following section shows you how to fully implement the CoreMedia Software Style for property editors.

Adding Advanced Property Editors Features

The String property editor template can be refined by the following features:

Adding validation or error messages that appear after incorrect user input.
Using the CoreMedia Software Style label look & feel, including
changing look & feel when the property is read-only.

The resulting meta template for String property editors looks like this:

<es:panelGroup
    element="div"
    styleClass="CMPropertyEditor CMTextWidth#{
                document.checkedOutByCurrentSession
                ? '' : ' CMDisabled disabled'}">
  <es:panelGroup element="div" 
    styleClass="CMPropertyToolbar">
    <es:label
      styleClass="CMPropertyLabel"
      value="#{document.type.descriptorsByName.
             ${property.Name}}"/>
  </es:panelGroup>
  <h:inputText
     id="${property.Name}Editor"
     value="#{document.properties.${property.Name}}"
     maxlength="${property.Length}"
     disabled="#{!(document.checkedOutByCurrentSession)}"/>
  <h:message for="${property.Name}Editor"/>
</es:panelGroup>

The template uses CSS style classes from the CoreMedia Software Style (files css/coremedia-style*.css). Of course, you can use your custom CSS design, either by using other style class identifiers or by replacing / adapting the style sheets.

The whole property editor is grouped by a div element that has a computed styleClass which takes care of the special look & feel:

CMPropertyEditor adds padding and modifies the behavior of other style classes inside a property editor (e.g. CMToolbar is right-aligned).
CMTextWidth sets a predefined width (50em) for the whole property editor that is appropriate for text editing.
CMDisabled disabled is set when the property is read-only, because the corresponding document is not checked out by the current user. CMDisabled disables the text of the property label and changes the border color of the text field, while disabled is needed to grey-out the property label's icon.

The label is wrapped by another div element that establishes the look & feel for property labels which may have a property toolbar (see below).

The <h:inputText> component has an arbitrary id, which must be unique with its JSF "naming container", i.e. the form component. The meta template suggests to use the property name suffixed by "Editor". If you want to do multi document editing, you may have to adapt the ID in order to make it unique. The id is needed to reference the field from the <h:message> component. It renders any validation or error messages, which a rare for String properties, but could result from a custom validator.

Defining Property Editors for Date and Integer Properties

The standard template for simple property editors that cover integers and dates looks very similar, as follows:

<es:panelGroup
    element="div"
    styleClass="CMPropertyEditor CMDateWidth#{
                document.checkedOutByCurrentSession
                ? '' : ' CMDisabled disabled'}">
  <es:panelGroup element="div" styleClass="CMPropertyToolbar">
    <es:label
      styleClass="CMPropertyLabel"
      value="#{document.type.descriptorsByName.
             ${property.Name}}"/>
  </es:panelGroup>
  <h:inputText
      id="${property.Name}Editor"
      value="#{document.properties.${property.Name}}"
      converter="#{converterFor[document.type.
                   descriptorsByName.${property.Name}]}"
      disabled="#{!document.checkedOutByCurrentSession}"/>
  <h:message for="${property.Name}Editor"/>
</es:panelGroup>

JSF supports automatic conversion from input string to typed value for typed properties. Because when editing CoreMedia Document properties, you specify a Map entry as the value binding, JSF cannot determine the correct property type - you have to declare a converter explicitly. The template sets the "converter" attribute to an EL expression using the ES helper Bean converterFor. This Bean is configured via Spring and returns an appropriate JSF converter for the type of the given CoreMedia document property. While for Strings it is of course not necessary, it does make sense for integers and dates. While the default handling of integers should be as expected, you may want to customize conversion of date properties.

Customizing Conversion of Date Properties

Note that in a CoreMedia document, dates are actually represented as java.util.Calendar objects (in order to maintain a time zone). Thus, for a CoreMedia DateProperty, the converterFor Bean returns a CalendarConverter (from package com.coremedia.editing.kits.jsf.converters). You can customize the converter used for DateProperties either

by changing the global Spring definition of converterFor_application (described below),
by assigning property-specific converters using Spring (see section), or
by specifying the desired converter directly in the JSP, using the <es:convertCalendar> custom tag (see section).

When configuring with Spring, you should not change any configuration file under in the configuration jars, instead edit a spring/ configuration file (e.g. spring/editing-jsf-views.xml) and use a Customizer on the Bean converterFor, property "calendarConverter". Here is an example of setting the default calendar converter to allow to edit date and time (the default is to edit date only):

  <customize:replace bean="converterFor" 
   property="calendarConverter">
    <bean class="com.coremedia.editing.kits.jsf.converters.
                 CalendarConverter">
      <property name="dateTimeConverter">
        <bean class="javax.faces.convert.DateTimeConverter">
          <property name="type" value="both"/>
          <property name="dateStyle" value="short"/>
          <property name="timeStyle" value="short"/>
        </bean>
      </property>
    </bean>
  </customize:replace>

Using Combo-Boxes

If you want to offer a combo-box instead of the plain text input field, you can do so by using the standard JSF component <h:selectOneMenu>. Just as the plain text input field, a JSF combo-box has a value binding to the property to be edited. Additionally, the select items (HTML: options) have to be specified. In JSF, you use the custom tags <f:selectItem> and <f:selectItems> to do so. While <f:selectItem> is used for single select items specified directly in the JSP, <f:selectItems> uses a backing bean to retrieve the desired select items. In both cases, each select item consists of a JSF SelectItem, which is essentially a pair of label and value.

A simple example of using a combo-box for the String property calories is shown in the following listing.

<es:panelGroup
    element="div"
    styleClass="CMPropertyEditor CMTextWidth#{
                document.checkedOutByCurrentSession
                ? '' : ' CMDisabled disabled'}">
  <es:panelGroup element="div" styleClass="CMPropertyToolbar">
    <es:label
        styleClass="CMPropertyLabel"
        value="#{document.type.descriptorsByName.calories}"/>
  </es:panelGroup>
  <h:selectOneMenu
      id="caloriesEditor"
      value="#{document.properties.calories}"
      disabled="#{!document.checkedOutByCurrentSession}">
    <f:selectItem itemLabel="<200 kCal" itemValue="<200"/>
    <f:selectItem itemLabel="200-300 kCal" 
     itemValue="200-300"/>
    <f:selectItem itemLabel=">300 kCal" itemValue=">300"/>
  </h:selectOneMenu>
  <h:message for="caloriesEditor"/>
</es:panelGroup>

When using ES, the preferred way to use combo-boxes is a model-driven, JSF-independent approach. using-combo-boxes documents how to apply this approach to arbitrary select item models and can easily be adapted for simple types like strings, integers, or dates.