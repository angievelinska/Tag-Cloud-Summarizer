

Finally, dimension constraints must be mapped to SQL expressions. This mapping is not automatically done but must be specified in the query configuration via the `dimConstraintExpressions¿ list-property. 

When a query is prepared for execution the specified mappings are evaluated sequentially. a From each mapping entry a partial SQL expression is generated, which is bound to a placeholder name. Finally, the statement placeholders are replaced with the generated expressions and the SQL statement is executed (see section above)

A dimension constraint can basically be mapped to any type of partial SQL statement (examples are conditional clauses, equality expressions or element-of expressions). A few mappings are predefined for relational queries:



SQL equality expression `columnName = value¿ as part of a condition clause:



query.addSqlEQUALSClause( String placeholder, String columnName, DimensionValueObject dimensionValueObject )



This will generate a literal expression `tablecolumn = dimensionvalueobject¿ and add it to the condition clause that is bound to the given placeholder. If the condition clause is not empty (other expressions have already been generated for that placeholder), the newly generated expression will be added as a conjunctive term to the clause.




SQL element-of expression `columnName IN (val1,val2,¿)¿ as part of a condition clause:



query.addSqlELEMENTOFClause( String placeholder, String columnName, Set<DimensionValueObject> valueObjectSet )



This will generate a literal expression `columnName IN (value1,value2,¿)¿ and add it to the condition clause that is bound to the given placeholder. Value1, value2, etc. are the enumerated values of the given value set. If the condition clause is not empty (other expressions have already been generated for that placeholder), the newly generated expression will be added as a conjunctive term to the clause.


JDBC configuration parameters:

query.setJDBCMaxRowsLimit( Integer value )

This will limit query's number of rows returned to the indicated value. Providing null as value will actually set no max rows limit.

Finally, the JDBC fetch size can be set with the following expression:

query.setJDBCFetchSize( Integer value )

Example:

<!-- Query definition -->
<bean class="...">
  <property name="queryName" value="Performance PI Query"/>
  ...
  <property name="sqlStatement" value="select ... from ... 
  {cond} group by ..."/>
  <!-- Defines a mapping of dim constraints to SQL clauses -->
  <property name="dimConstraintExpressions">
  <list>
  <value>query.addSqlEQUALSClause( 'cond', 'stats.SITE',
     dataModel.dimConstraint('site'))</value>
  </list>
  </property>
</bean>

In the example above, the current value of dimension constraint 'site' is retrieved. Assuming that value is 'Core.com', an SQL 
fragment "stats.SITE = 'Core.com'" is created and bound to the placeholder 'cond'.

The expression notation used in dimension constraint mapping expressions is very similar to native Java expressions, with two exceptions:

single quotes can be used to denote string literals;
property access that follows standard JavaBean conventions can be abbreviated: x.y.z is evaluated to x.getY().getZ().

The expressions are evaluated dynamically. At evaluation time, the variable 'dataModel' is bound to the data model and the variable 'query' is bound to the current query. The methods invoked are actual methods of the query classes (see class com.coremedia.analytics.definition.report.query.AbstractRelationalDataModelQuery for SQL/JDBC operations) and data model classes (see class com.coremedia.analytics.definition.report.datamodel.AbstractReportDataModel for dimension constraint definition). You may add methods to your customized query classes and use them in the constraint mapping expressions. This very generic approach has been chosen to provide flexibility when mapping constraints to query languages like SQL. Please note that in later versions however, this generic notation might be replaced by a more restricted notation.