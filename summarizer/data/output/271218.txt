

The CoreMedia Lightweight Portal implements portlet output caching according to the JSR 286 specification.

Caching Architecture

Through configuration in the deployment descriptor, and through the cache control API, a JSR 286 portlet can indicate whether its output is cachable, when it expires, whether it may be revalidated, and whether it contains session- or user-specific (private) information. All cached output for the portlet window is discarded when the portlet window becomes the target of an action url, or receives an event.

In the CoreMedia implementation, both private cache entries and public cache entries are stored in the CAE cache. The public cache can hold multiple renditions of the same portlet window at the same time, provided they have different window states and render parameters, or in the case of private cache entires, have been rendered for different users or sessions. Currently, portlet output is only cached in portlet mode VIEW.

Configuration

There are currently only two parameters that affects caching. 

portletcontainer.cache.public
portletcontainer.properties.private

In WEB-INF/spring/portletcontainer.properties, you can configure the number of characters of cached portlet output that should be cached in the public scope, and the number of characters that should be cached in the private scope. The default is 50000 in each case, making for twice 100kB of heap size.

Caching for Resources

For resource URLs, the responsibility for caching is delegated to the client's browser or intermediate HTTP proxies, by mapping the cache control API to HTTP headers.

Developing Portlets for Caching

In order to achieve optimal cachability for your portlets on a live web site, and keep memory usage low, the following guidelines should be used when developing and deploying portlet applications:

use cache scope public where possible
activate caching by defining expiration times
use render links where possible, instead of action links
use public render parameters instead of events

You may also want to set an ETag to support revalidation.

Note that portlet output that goes to the public cache must not depend on the current session, let alone the current user. It may depend only on window state, portlet mode, and render parameters, and the shared portlet preferences of the portlet instance.

For private portlet output, it may be more memory efficient not to cache the portlet output, but instead use caching inside the portlet application to make render requests run quickly.

To avoid surprises, you should generally never change state (such as session attributes) in a portlet's doRender method, but only do it in doAction or doEvent.

Caching during development

During development, when you change the code of your portlet application, cached portlet output can be annoying, because you do not see the effect of your changes. It is then important to understand how to render fresh content. You can take the following measures:

for private scope, you may end the current session (log out or delete the browser cookie) and start a new session.
for public or private scope, click an action link on the portlet window.
for public or private scope, you may also restart your servlet container. All caches are empty when the servlet container starts up.
if you do not use ETags, and expiration times are limited, you could just wait. Note that when using ETags, cached portlet output may stay in the cache indefinitely.
disable caching in the deployment descriptor and redeploy, and start a new session. This only works if the portlet application does not programmatically enable caching.
for cached resources, flush your browser cache, or directly open the resource URL in a browser window and click (shift) reload.