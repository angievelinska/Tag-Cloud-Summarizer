

Using the <es:button>-tag is the easiest way to create a button that is localized according to the action being the button's value and invokes the action's execute() method. The definition of the login button in a custom login.jsp might look like this:

<es:button id="customLoginButton"
    type="submit" value="#{loginAction}" mode="text"/>

When using an action that does not have a predefined target you can set an ad-hoc target using the the public API actionFactory_application bean. This can be useful if an action has to be rendered multiple times each working on its own target. Image you designed an edit view that works on two documents having the bean names document1 and document2. In this case you can reuse the contentCheckInOutAction action and define buttons as shown below.

<es:button id="checkInOutButton1" type="button"

    value="#{actionFactory[contentCheckInOutAction][document1]}"/>
    ...
<es:button id="checkInOutButton2" type="button"
    value="#{actionFactory[contentCheckInOutAction][document2]}"/>

In some cases you might prefer the standard JSF <h:commandLink>- or <h:commandButton>-tags. This will usually be the case if you have to use nested tags (e.g. <h:graphicImage> or <h:outputText>) with your button. In order to use these tags with ES actions you have to create an action listener with the help of the public API listenerFactory_application  bean. The definition of the login button in  a custom login JSP using standard JSF tags might look as follows:

<h:commandButton id="customLoginButton"
    actionListener="#{listenerFactory[loginAction].processAction}">
    ...
</h:commandButton>

The two utility beans listenerFactory_application and actionFactory_application can even be nested if an action listener has to be used with an action created by the actionFactory_application utility bean.