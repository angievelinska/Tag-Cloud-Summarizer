

Examples of services in ES  are

a table service that, given some Content folder and a set of columns, returns a list of table rows that each contain certain properties of the contained Content items, or
a localization service that, given a predefined Content action bean like ¿Check-out Document¿, return its ready-to-be-rendered localized appearance.

Examples of models are

A ListModel that maintains a snapshot of a list of Java Beans, or
a LocalizedLabel that is a model for a label with icon and tool tip.

Example of utilities are

classes for extended integration of JSF and Spring, or
a Bean that can be used in JSF-EL to compute the size of any Collection or array.

Examples of components are

a table component that takes a table model, renders it, sorts it according to the selected column, and offers paging buttons to browse through the table entries, or
a button component that takes an action, presents it in the UI, and invokes the action when clicked by the user.

All such entities are called building blocks in Editing Services for JSF. The approach is to provide such Content UI building blocks rather than a monolithic configurable generic solution. The advantages are:

The configuration level is more fine-grained: each service, model, and component is configurable, not the view as a whole. Each building block, not the whole application, can be generic.
Building blocks are easier to reuse, even in other contexts.
When using standard component frameworks like JSF, Rapid Application Development (RAD) tools, also called GUI builders, can be used to create content applications interactively and graphically.

Custom extensions of Editing Services are possible, allowing to define custom services, models, and components that build on top of the existing ones. The extension and customization mechanism is based on standard Java Beans, so the Spring framework (see below) can be used for the overall setup. For the connection to the CoreMedia Repository, there are Content-specific services, models and utilities. This means that custom extensions can also integrate other data sources, and still use core features of Editing Services like localization and actions. In other words, the core Editing Services framework is much more an abstraction of other UI frameworks than a CoreMedia-Content-specific implementation. Still, when using Editing Services for CoreMedia Content Applications, you do not need to care about this aspect, because the concrete implementations needed for this type of solutions are all there.

The CoreMedia Content-specific part of Editing Services uses the Unified API introduced in CoreMedia CMS 2005. Thus, any business logic developed using the Unified API  can be reused in an Editing Services-based UI. For further discussion of Editing Services and UAPI, see below.

The concrete components provided by Editing Services  are JavaServer Faces (JSF) components. 

This chapter describes the services, models, components, and utilities offered by Editing Services for JSF in CoreMedia CMS. Its goal is to give an overview and show how the different parts of Editing Services work together. Please refer to the JavaDoc (Java API), BeanDoc (Spring configuration), and TldDoc (documentation of JSF component TagLibs) of Editing Services when you need further details.