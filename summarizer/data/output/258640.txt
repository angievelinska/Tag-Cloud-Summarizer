

In general, a custom controller implementation needs to implement the interface org.springframework.mvc.Controller. The web page http://static.springframework.org/spring/docs/2.0.x/reference/mvc.html#mvc-controller discusses controllers in general.

In the first place, a controller looks strikingly familiar to a servlet: it is found due to an URI mapping and its input is a servlet request and response. But there are some differences. First of all, controllers are not instantiated by the servlet container but by the Spring bean container. That means they can receive required services through dependency injection instead of the servlet context. Also, their output is a little more interesting: after handling a request, a controller needs to return an object of type ModelAndView. This is a pair of a Map (the model) and a view name. The model contains named (result) objects which can be retrieved and displayed by the view. In JSP-based views, the model map will typically be exposed as request attributes, thus easily accessible through JSP EL.

The Content Application Engine picks up the result (through a custom ViewResolver implementation) and directs it to the view dispatcher for display. In order to participate in the Content Application Engine's templating, the model needs to contain an entry named "self". The corresponding object will be subject to view dispatching using the returned view name. The Content Application Engine comes with some static convenience methods in the class ControllerUtils to create such ModelAndView objects. For example, a controller that wants to render a black bean would look as follows:

public class BlackBeanController extends AbstractController {
  protected ModelAndView handleRequestInternal(
    HttpServletRequest request, HttpServletResponse response) {
    // render a black bean cooked
    BlackBean b = new BlackBean();
    return ControllerUtils.viewOf(b, "cooked");
  }
}

The method viewOf will create a ModelAndView object that contains

a mapping "self" -> a BlackBean as model
"cooked" as the view name

Correspondingly, the view dispatcher will now look for a template BlackBean.cooked.jsp.

Note that the model can contain auxiliary beans next to "self". See the class com.coremedia.objectserver.web.ControllerUtils for a complete list of methods to create and populate ModelAndView objects. In the Content Application Engine you should always use the factory methods in ControllerUtils since they deal with the "default" view name (null). The "raw" Spring APIs do not allow for a null view name.

In order to enable a controller, you need to define it and add it to the URI mapping in your project specific <myComponent>-controllers.xml:

<bean id="blackBeanController"
      class="com.company.BlackBeanController"/>
...
<bean id="customControllerMapping" ...
...
  /blackbean=blackBeanController
...

All requests to <context>/servlet/blackbean are now directed to the black bean controller (/servlet is the mapping of the Spring dispatcher servlet in web.xml. You can change its prefix to your likings. Unfortunately, the empty prefix (/*) does not work, JSP templates will not work if you configure that.