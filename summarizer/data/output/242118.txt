

When a task is activated, i.e. its guard check has been passed, it may be offered to several users. By default, all users that have the right to accept the task (see ###Rights), and have not rejected the task yet, appear in the set of offered users. A task may also be assigned directly to a user or to a group, or a certain performer may have been forced by a previous task.  The strategy for offering tasks to users can be overridden by providing a customized performers policy (see the Workflow Manual for details), or by changing the handling of the accept right in a custom rights policy (see ###RightsPolicy).

The set of users a task is offered to may be inquired using the method Task#getOfferedTo(). All tasks that are offered to the current user can be determined using the work list service (see ###Worklist). Changes to a task's set of offered users are signaled by TaskOfferedEvent and TaskRevokedEvent instances (see ###Events).  There are no events for changes to the work list. Instead, when working inside the CAE caching infrastructure, your code simply calls the work list getters, and can rely on the correct dependencies being registered behind the scenes. In this way, your code will be automatically re-executed when any accessed work list changes.  See the CAE Developer Manual and ###Cache for further details.

A task's guard condition may become false before the task is accepted by any eligible user.  In this case, the task goes back to the waiting state.

The user who accepts a task becomes the performer of the task. This entails certain privileges required to perform the task, namely the ability to read and write the task's variables, and the ability to cancel, complete or retry the task.

Before passing control to the user, first, the task's preconditions are checked.  This feature can be used to verify assumptions by the workflow designer.  If a condition is not met, the task is escalated. If all checks are passed, the task's entry actions are executed.  This may include GUI-based remote client actions, which will be executed in the name of the user (see ###RemoteClientAction).

The Unified API offers the method Task#acceptAndEnter(), which waits until the task has safely arrived in the running state.  Any exceptions thrown by failing preconditions or entry actions are passed on to the method's caller. This allows for a synchronous programming model:  When acceptAndEnter returns normally, you can be sure that the task is running.  In contrast, accept supports an asynchronous programming model, insofar as it only triggers the server-side computation.  When accept returns, the server-side code may not have finished yet.

A task can be passed directly from one performer to another using the method Task#delegate(). The task remains in the running state, no conditions are checked or actions executed.

A task may also be cancelled, sending it back to the activated state. The user ceases to be the task's performer. Again, post conditions are not checked, and exit actions are not executed.

Note that these methods may also be invoked by a different user than the performer, assuming the respective rights are granted.  For example, when a user is on vacation and has left behind some running task, an administrator or process owner may still lead the process to conclusion by delegating or canceling the task. An additional option for a user task is to skip the task, in order to make progress even when no suitable performer can be found.

A call to Task#complete() indicates to the workflow server that the user has finished his or her work. All configured post conditions are checked.  If any post condition fails, the user probably has not fulfilled his  task as planned. The task becomes escalated, and may be retried by the performer, returning it to the running state.  Note that the current performer is remembered while the task is escalated and/or suspended.

After all post conditions are successfully checked, the configured exit actions are run, and the task changes to state completing.  Similar to acceptAndEnter, the method Task#completeAndExit() synchronously waits until the task including all post conditions and server-side actions has completed, and passes any exceptions on to its caller.

The remaining lifecycle is as described for automated tasks, above.