

When extending the Data Aggregator, it may happen that you actually want to create some tables specifically for the data you are importing or for the reports you are trying to generate. Traditionally, this is done by providing SQL scripts that must be run by the database administrator while a component is installed. However, it is more convenient if a component detects the need for modifications to the database schema automatically, running the necessary statements automatically.

You can request an automatic update of the Analytics Database for your own extension by placing a script file with the file name extension .sql in the directory config/dataaggregator/sql of the Data Aggregator installation. This custom database update script consists of a number of batches, each of which consists of a number of SQL statements and possibly control statements. Such a script might look like this:

-- Foobar DB extension
-- (C) 1972 Foobar Inc.

--- BATCH foobar 0 1
CREATE TABLE Foo (foo VARCHAR(10));
--- ENDBATCH

--- BATCH foobar 1 2
CREATE TABLE Bar (bar VARCHAR(20));
INSERT INTO Bar VALUES ('');
--- ENDBATCH

While lines prefixed with -- are generally treated as pure comments, lines starting with a --- marker actually indicate the start of a control statement. In this case, they delimit two batches that ensure that the tables Foo and Bar are properly set up. The keyword BATCH is followed by three argument: an aspect name, a source version and a target version.

Aspects group multiple batches that logically belong together and that build upon each other. An aspect for which no batch has ever run is assigned the version 0. Batches normally increase the version number by 1. In the example the first batch advances the version of aspect foobar from 0 to 1 and the seconds batch from 1 to 2. The fact that two batches exist reflects the history of the database schema where at some point of time only the table Foo was used, but later on the need for table Bar became obvious.

Batches are processed in a sequential fashion, executing only those batches for which the specified source version matches the current version of the specified aspect. After the batch has been executed successfully, the version of the aspect is advanced to the target version and the next batch is processed. The versions of all aspects are stored persistently in the database, so that future runs of the update algorithm can detect that the database schema is already present in the correct version. In the example the old version of the aspect foobar may be either 0, 1, or 2 and in any case the new version will be 2, executing both batches, the second batch, or no batch, respectively.

While custom update scripts may refer to more than one aspect, it is generally a good practice to keep the number of aspects as low as possible.

Updates in one custom update script may not depend on the changes performed by other custom update scripts. This means that you must not refer to one aspect in more than one update script. The update scripts for the standard database schema of CoreMedia Analytics are executed before all other update scripts. CoreMedia Analytics uses the aspect base to manage its version.

We will now look at the constructs allowed within a batch definition.

Statements

The individual statements in a batch must be terminated with a semicolon (;). Empty lines may separate one statement from another. Statements may contain placeholders delimited by at-signs (@). Before execution such placeholders are converted in a database specific way. Often, this allows to write update scripts that abstract from the exact database product used. The following placeholders are predefined: