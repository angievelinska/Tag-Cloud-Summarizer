

When writing an own ActionForm for accessing CoreMedia resources, it is important to extend the WageActionForm. Our DishActionForm tries to get the current CoreMedia resource whenever a getter or setter is called by calling getCurrentResource(), a method provided by the WageActionForm. This will evaluate the resource and collector request parameters and set the appropriate resource and ChangeCollector. It is therefore essential that this method is called before an Action working on CoreMedia resources or a ResourceActionForward is used, as these require the current resource and ChangeCollector to be set. This is only possible if at least the resource parameter is set (the default ChangeCollector will be used then). This is why we included the (hidden) resource form field in our renderForm.jsp template.

As the resource parameter also could be a multipart form parameter (needed when file upload is being used, e.g. for BLOB properties), you may not access getCurrentResource() in the constructor of an ActionForm. Instead, call this method every time you want to access the current resource, as shown in the DishActionForm example.

The setResource() method in DishActionForm looks a bit funny: It does nothing at all. The reason why this method has to be there is that when Struts finds a request parameter resource, it looks for a property of the same name in the form bean. Since we implement getResource(), such a property is found. Struts then tries to write to the property, using the corresponding setter. If there is no such setter, an Exception is thrown. Thus, the setter has to be there, but must not do anything at all, since the actual work of setting this resource as the current resource has already been done by the CMRequestProcessor. Unfortunately, the straight-forward solution to set the current resource when setResource() is called on the form bean is not possible, since the order in which form bean properties are populated by Struts is not defined. When setting other properties, we already need to know the current resource, so we have to set this special property in advance.

Besides this basic functionality which will be nearly the same for every ActionForm, we only implemented a getter and a setter method for the name property of a Dish document. The getter method is called for filling the form with the current resource property value, the setter method is called when the form is submitted with the (probably changed) value of the name property.

When the setter is called, the change is only stored locally in the ChangeCollector for a specific client (see xxx). Only when the Action commits the ChangeCollector, the changes are stored permanently on the server. In our case, the ChangeCollector is always committed after submitting the form, but this doesn't have to be the case necessarily (see for example XXX).

Of course it wouldn't have been necessary to write this DishActionForm class at all, as we could have used the generic WAGE ResourceActionForm as well, without writing a single line of code. This is just an example for writing an own ActionForm which makes the interface to the business object more explicit and may e.g. provide read/write access to some calculated properties (e.g. first name + last name).

Another reason for implementing your own ActionForm classes could be for example if you want to access (read from and write to) other business objects (besides CoreMedia resources) in a single form, or to access multiple CoreMedia resources in a single form (see XXX).