

This chapter gives you an overview of how to write your own Proactive Engine application. Although the API is mentioned, it is not described at a detailed level here. Consult the API documentation of the package com.coremedia.cap.persistentcache.proactive for further details.

Writing a Proactive Engine Applications includes

Implementing one or more Triggers or alternatively, implementing the Content Trigger framework¿s artifacts .
Implementing one or more Receivers.
Registering these implementations in a runtime environment.

Implementing a Receiver

As already mentioned, a receiver is a component which receives key/value based events in order to do further processing on them such as handing the values over  to another system. In order to write a receiver, you have to implement the interface com.coremedia.cap.persistentcache.proactive.Receiver. Most of the interface¿s methods represent an event which may be processed asynchronously. The event should be answered using the provided com.coremedia.cap.persistentcache.ProcessingCallback when processing is complete. 

Implementing a Trigger 

A trigger is a component which accesses the Proactive Engine via the interface com.coremedia.cap.persistentcache.proactive.KeyManager, telling the Proactive Engine which PersistentCacheKeys to compute proactively. When writing your own trigger, you have to make sure that a KeyManager can be configured from outside the component, e.g. by providing a method setKeyManager(KeyManager). In addition, you have to provide a PersistentCacheKeyFactory which is able to reconstruct the Trigger's cache keys.

Keep in mind that any changes to the KeyManager¿s state (for instance the addition of a new key) are stored persistently. For this reason you should make your trigger resume its work after a restart rather than starting from the beginning: All modifications to the KeyManager¿s state which have been successfully answered by the KeyManager must not be repeated. 

As a starting point for implementing a trigger, the abstract class com.coremedia.cap.persistentcache.proactive.TriggerBase may be useful. When using the higher level Content Trigger framework, you don¿t have to deal with these trigger related issues by yourself. Instead, you only have to implement the interface com.coremedia.cap.persistentcache.proactive.ContentEvaluator and optionally the interface com.coremedia.cap.persistentcache.proactive.ContentSelector.

Using the Proactive Engine application template

CoreMedia provides a Proactive Engine application template, which is a runtime environment for bringing together your Trigger and Receiver implementations in an application. Before running your Proactive Engine application, you have to adapt the template: First of all, copy a JAR containing your trigger and receiver implementations into the directory lib/. After that, you have to register your custom implementations in a number of configuration files. The application template¿s configuration is mostly based on the spring framework¿s bean configuration concept (http://www.springframework.org). It is assumed that you are already familiar with the spring framework's configuration concepts. 

The most important configuration files are proactiveengine-triggers-example.xml and proactiveengine-receivers-example.xml which are located below config/proactiveengine/spring. As the names suggest, the first file is the place to register your trigger implementations, while your receiver implementations are registered in the second one. The configuration files proactiveengine.properties and log4j.properties consist of administration related configuration entries such as database and logging related issues. The details are described in the Administration and Operation Manual. 

proactiveengine-receivers-example.xml

In order to register your receivers, for each receiver you simply need to add a bean entry below the enclosing <list>, such as the following

<bean name="myReceiver" 
class="com.mycompany.MyReceiverImplementation">
 ...
</bean>

As an default, two instances of a LoggingReceiver are registered. This type of receiver does nothing except log and acknowledge all incoming events.

proactiveengine-triggers-example.xml

The configuration of the triggers is a bit more complex. From an abstract point of view, this configuration consists of the following elements:

One or more trigger bean declarations which reference a bean keyManager of type com.coremedia.cap.persistentcache.proactive.KeyManager. The key manager bean is defined in the framework part of the configuration. 
For each trigger, an adequate PersistentCacheKeyFactory. 
A composite PersistentCacheKeyFactory bean called ¿triggerPersistentCacheKeyFactory¿, which aggregates all trigger¿s factories. This bean is used by the framework.

The concrete default configuration consists of a ContentTrigger bean (called "trigger1") and its PersistentCacheKeyFactory (called "trigger1PersistentCacheKeyFactory"). A PathAndTypeContentSelector bean is used as the ContentSelector while the implementation PathContentEvaluator is used as the ContentEvaluator. Latter should be understood as a very simple example which computes the path of a content.

Register your own triggers and their PersistentCacheKeyFactory implementations by adding entries like

<bean name="myTrigger" 
  class="com.mycompany.MyTriggerImplementation">

  <property name="keyManager" ref="keyManager"/>
  ...
</bean>
...
<bean name="myTriggerPersistentCacheKeyFactory" class=
"com.mycompany.MyPersistentCacheKeyFactoryImplementation">
  ...
</bean>

and reference the PersistentCacheKeyFactories from inside bean triggerPersistentCacheKeyFactory like

<bean name="triggerPersistentCacheKeyFactory" class="
com.coremedia.cap.persistentcache.
CompositePersistentCacheKeyFactory">

 <property name="keyFactories">
  <list>
  ...
  <ref bean="myTriggerPersistentCacheKeyFactory"/>
  </list>
 </property>
</bean>
