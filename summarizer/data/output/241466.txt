

Struts suggests and supports a three-tier architecture for Web applications, the "Model 2" approach, a variation of the classic "Model-View-Controller" (MVC) design paradigm.

One part of the MVC design pattern is a central controller which is responsible for the control-flow of an application. It delegates requests (e.g. HTTP requests) to an appropriate handler. Each handler is bound to a model and acts as an adapter between the request and the model. The model encapsulates the application's business logic or state. After handling a request, the control is usually forwarded back through the controller to an appropriate view.

In the Model 2 approach servlets are responsible for the control flow of a Web application, whereas JSPs are used for writing out HTML. In Struts, there is only one servlet that dispatches control to so-called Actions, so that request processing and business logic are seperated.

The model can be divided into two subsystems: the internal state of an application and the actions that can be taken to change that state. Many applications represent the internal state as a set of JavaBeans (the business objects) where the bean properties represent the details of the system's state. Actions (or business operations) then are represented by methods that can be called on the beans maintaining the state information. Struts also supports other approaches for accessing the model part of a MVC architecture, but we'll use this one based on JavaBeans.

JSP templates are used only as view, i.e. they contain no business logic (like computing some derived property) nor have they knowledge of business processes (like where to continue after a form is submitted). Development of such JSP templates is supported by Struts with several tag libraries. The tag libraries abstract from concrete HTML elements and provide I18N support through Java resource bundles. Furthermore, tags for JavaBeans and for loops and conditionals are provided. 

Struts also lets you define JavaBeans representing views on business objects based on business processes. These beans (ActionForm beans) represent forms that collect data from the Web front-end.

The controller portion of the application is focused on receiving requests from the client (typically a user running a Web browser), deciding what business logic function is to be performed, and then delegating responsibility for producing the next phase of the user interface to an appropriate View component. In this way controller components take care of the sequence of forms presented to the Web user. In Struts, the primary component of the Controller is a servlet of class ActionServlet. This servlet is configured by defining a set of ActionMappings. An ActionMapping maps a request URI to an Action class, subclassed from org.apache.struts.action.Action. Actions encapsulate the business logic, interpret the outcome, and ultimately dispatch control to the appropriate View component to create the response.

When developing a WAGE or Struts based Web application, you will have to write your own components based on the following Struts classes (or WAGE subclasses thereof, see XXX):

ActionForm: The Struts framework generally assumes that you have defined an ActionForm bean for the input forms in your application. There may be one bean for each form, but a bean can also serve several forms, or even an entire application. If an ActionForm is declared in your Struts configuration file, the Struts controller servlet will automatically perform the following services for you, before invoking the appropriate Action method:

Create a new form bean and add it to the configured scope (request or session; session form beans are reused within the user's session and not re-created on every request).
For every request parameter whose name corresponds to the name of a property in the bean, the corresponding setter method will be called. This operates in a manner similar to the standard JSP action <jsp:setProperty> when you use the asterisk wildcard to select all properties. Struts calls this phase bean population.
The updated ActionForm bean is then passed to the execute method of an Action class (org.apache.struts.Action), so that the values can be made available to your system state and business logic beans.

Please note that a "form", in the sense discussed here, does not necessarily correspond to a single JSP page in the user interface. It is common in many applications to have a "form" (from the user's perspective) that extends over multiple pages. Think, for example, of the wizard style user interface that is commonly used when installing new applications. Struts encourages you to define a single ActionForm bean that contains properties for all of the fields, no matter which page the field is actually displayed on. Likewise, the various pages of the same form should all be submitted to the same Action Class. If you follow these suggestions, the page designers can rearrange the fields among the various pages, often without requiring changes to the processing logic.

A form bean needs not to be "flat": if the value of a property is again a JavaBean, you can access its properties using Struts' nested property expressions. These are similar to JSTL expression language: nested properties are denoted by their property name and seperated by a dot ('.'). You can access three types of properties of any JavaBean or DynaBean:

simple properties that usually have a type of String,
indexed properties that are Arrays or Lists, denoted by an index in square brackets ('[1]') and
mapped properties that take a single String parameter or return a Map, denoted by round brackets ('(key)'). 

An example of a nested property that uses an index and a simple property is 'relatedContent[0].headline'.

Action: The goal of an Action class is to process a request, via its execute method, and return an ActionForward object that identifies where control should be forwarded (e.g. a JSP or another Action, where forwaring to Actions is controversial) to provide the appropriate response. In the MVC/Model 2 design pattern, a typical Action class will often implement logic like the following in its execute method:

Validate the current state of the user's session (for example, checking that the user has successfully logged on). If the Action class finds that no logon exists, the request can be forwarded to the presentation page that displays the username and password prompts for logging on. This could occur because a user tried to enter an application "in the middle" (say, from a bookmark), or because the session has timed out, and the servlet container created a new one.
If validation is not complete, validate the form bean properties as needed. If a problem is found, store the appropriate error message keys as a request attribute, and forward control back to the input form so that the errors can be corrected.
Perform the processing required to deal with this request (such as saving a row into a database). This can be done by logic code embedded within the Action class itself, but should generally be performed by calling an appropriate method of a business logic bean.
Update the server-side objects that will be used to create the next page of the user interface (typically request scope or session scope beans, depending on how long you need to keep these items available).
Return an appropriate ActionForward object that identifies the presentation page to be used to generate this response, based on the newly updated beans. Typically, you will acquire a reference to such an object by calling findForward on either the ActionMapping object you received (if you are using a logical name local to this mapping), or on the controller servlet itself (if you are using a logical name global to the application).

ActionForward: An ActionForward tells an Action where to proceed after processing a request. For example there could be an ActionForward "success" which leads to a welcome page, and an ActionForward "failure", which leads back to the login page of a Web site. Each ActionForward has a symbolic name that the ActionMapping evaluates to a path.

ActionServlet & Request Processor: The Struts ActionServlet is the central target for all requests. According to an action mapping (defined in the Struts configuration file struts-config.xml), an action form and action are instantiated. The action form and the HTTP request are handed over to the action as parameters of the execute() method. The result of the action determines the JSP that actually renders the form. When the form is submitted, the same action form object is used and automatically "filled" by the Struts ActionServlet. Then the action is executed again, for example to tell the action form to save its data. Another JSP is returned to continue the user interaction.

Converters: Often it is necessary to convert objects from one type to another, for example when reading in a request parameter as String, that reads true or false and has to be converted into a Boolean object. Struts uses the org.apache.commons.beanutils.converters package, which already has converters for the common types. It is also possible to write own converters, which have to implement the org.apache.commons.beanutils.Converter interface. Struts' converters are rather limited:
Only one converter can be defined for each combination of source and target class.
Conversion errors may be thrown, but cannot be processed adequately in the request life-cycle. Only ActionForm validators and Actions may return ActionErrors.

This is why WAGE provides its own property converter framework (see property-conversion).

Struts also supports the development of JSPs by providing some tag libraries, for example:

struts-html: Tags to create Struts input forms as well as tags generally useful in the creation of HTML-based user interfaces.
struts-bean: Tags used to access beans and their properties, and to create new beans.
struts-logic: Tags to support loops / iterations and conditionals.

For examples on how to use some of the most common Struts tags, see XXX. For a complete reference of the Struts tag libraries, please refer to the Struts User Guide.

The following diagram illustrates the interrelationship between the different Struts components: