

In the previous example only Strings were interchanged between the server and the client.  Now you will see how to deal with more complex objects, namely CMS Content objects.  The client of this example prints out the folder structure of the CMS content repository.

The WebService class Folder exposes two WebMethods getRoot and getSubfolders.  You have to consider two points:

The client needs the folder names to print the structure and the IDs to request the subfolders.  So you cannot simply reduce a folder to a single String (path or ID like in the first example) put have to pass a complex content object.
A CMS related WebService may be based on UAPI or (preferably) on CAE content beans.  In either case the content object types are interfaces, and JAXB processors have no default handling for interfaces as portable artifacts (i.e. arguments and return values of WebMethods). There is a number of technical reasons for this limitation, see http://weblogs.java.net/blog/kohsuke/archive/2006/06/jaxb_and_interf.html for details.

These issues are covered by the interface ContentMetaData.  It features name and ID of CMS content, which are independent of any concrete document types, so you can run this example with arbitrary CoreMedia CMS repositories. The @XmlJavaTypeAdapter annotation tells the JAX-WS runtime to use a ContentMetaDataAdapter to marshal ContentMetaData objects, because JAXB processors cannot handle interfaces.  ContentMetaDataAdapter marshals the business objects into ContentMetaDataImpl objects.  ContentMetaDataImpl is backed by a UAPI Content object and carries JAXB annotations which specify the details how to map the properties to XML.  ContentMetaDataImpl objects are instantiated in different contexts, therefore the class needs several constructors and setters: