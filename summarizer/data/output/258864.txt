

As stated by the JSF javax.faces.FactoryFinder API class comment, JSF searches for factories as follows:
Look for a factory declaration in a JSF configuration file in the webapp's WEB-INF directory.
Look for a factory declaration in one of the JSF configuration files named by the javax.faces.CONFIG_FILES init parameter of the JSF servlet.
Search the META-INF directory of any jars on the JSF servlet's resource paths for factory declarations with the last one taking precedence.
Search the META-INF/services directories for resources named after one of the JSF factory classes and assume the first line of it to contain the name of the factory implementation class to use.

Editing Services for JSF provide implementations for JSF RenderKitFactory and ApplicationFactory in cap-editing-jsf.jar by defining factories following step 4:

META-INF/services/javax.faces.render.RenderKitFactory 
META-INF/services/javax.faces.application.ApplicationFactory

Both implementations try to locate the servlet context's spring application context in order to find or configure a JSF RenderKit or a JSF Application respectively. If they cannot access a spring application context, they delegate to the JSF implementations default factories. This allows to use plain JSF configuration in conjunction with spring's bean factory capabilities to set up JSF UIComponents, Renderers, Converters and the like. Lets have a look at these factory implementations.

While the SpringRenderKitFactory simply returns the first RenderKit found by spring, the SpringApplicationFactory returns an instance of the SpringApplication class that has to be post-configured by spring. The post-configuration of the SpringApplication instance is done using the following spring bean definition that resides in WEB-INF/spring/editing-jsf/dispatcher-servlet/editing-jsf.xml.

<bean id="springApplicationConfiguration" abstract="true"
      class="com.coremedia.editing.kits.jsf.util.spring.\
             SpringApplication">
   ... [ YOUR_CONFIGURATION]...
<bean>