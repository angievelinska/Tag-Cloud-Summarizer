

You can render objects of type com.coremedia.xml.Markup by including them into a JSP using:

<cm:include self="${aMarkup}"/>

This uses the class XmlMarkupView as a default view, which converts richtext to XHTML applying the following transformations:



internal links are converted to URIs pointing back into the CAE


links (href attributes in the xlink namespace) without protocol and server are URL-encoded


anchor and image elements with xlink href attributes are converted to xhtml a href and img src.


the CoreMedia Richtext namespace is dropped from the elements

If you want to use your own transformations you have to proceed as follows:
Define your own view, plain for example, in spring/cae-views.xml using a Customizer:

<customize:append id="programmedViewsCustomizer" bean="programmedViews">
  <map>
    <entry key="com.coremedia.xml.Markup#plain">
      <bean ..../>
    </entry>
  </map>
</customize:append>

2#
Use XmlMarkupView as the implementation of the view, but apply a custom filter factory which creates a SAX filter-chain  per output. Proceed as follows:

Let your filter factory extend RichtextToHtmlFilterFactory.
Overwrite #createFilters  and append your own transformations before super.createFilters.

public List createFilters(HttpServletRequest req, 
HttpServletResponse res, 
Markup markup, String view) {
List result = new ArrayList();
result.add(new MyFilterForRichtext());
result.addAll(super.createFilters(req, res, markup, view));
}
3#
Configure your filter factory in cae-views.xml as follows:

...
<entry key="com.coremedia.xml.Markup#plain">
  <bean class="com.coremedia.objectserver.web.XmlMarkupView">
    <property name="xmlFilterFactory">
      <bean class="com.coremedia.objectserver.web.
      MyRichtextToHtmlFilterFactory">
        <property name="idProvider" ref="idProvider"/>
        <property name="linkFormatter" ref="linkFormatter"/>
     </bean>
    </property>
  </bean>
</entry>
...


