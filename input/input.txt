Using the importer in order to import third party content you must basically take care for two aspects: Serve the source content Transform the source content into CoreMedia XML The importer framework provides an out-of-the-box solution for source content available as files. Alternatively you can implement your own factory, e.g. to serve content from a database, over some network protocol or to generate content on the fly, composed from arbitrary sources. As your source content is most probably not available in CoreMedia XML format matching your document types, you will have to transform it. The importer supports XSLT transformations (you just have to configure the stylesheet) as well as stream based cross-document transformations for arbitrary (even non-XML) sources.See the Importer Developer Manual for details.
According to the underlying content model the CoreMedia Editor  generates forms for resource editing. The default forms provide editing facilities for each property of a document (so called property editors), general editing functionality like copy&paste and CoreMedia CMS  version control features (see User Manual, Basic Knowledge). You can control the layout and behavior of these forms concerning the following aspects:  use special property editors (e.g. a string editor which automatically converts to upper case. CoreMedia provides some alternative property editors to use, but you can also implement your own.)initialize and validate input (e.g. make sure that an integer value is greater than 42) provide complex commands (e.g. create a new document and link it into some navigational structure) Furthermore you can control localization language specific spell checking * rich text formatting * filters to hide some objects from the users (e.g. document types they are not supposed to instantiate or folders that do not concern them) * renderers to display objects (e.g. the fields in the document table) Many Editor features can be achieved or controlled simply by configuration, without writing a single line of code. However, understanding all the possibilities requires some knowledge of Java. See the Editor Developer Manual for details.Different content domains deal with different data. While a news portal consists basically of short texts, pictures and navigation structures, mobile services deal with multimedia objects like ring tones, animations and games, each for a variety of devices. Different content has different properties. E.g. an article consists of a headline, the actual text and possibly references to related subjects, whereas a multimedia object needs binary data and maybe a description.
The first step in designing a CoreMedia CMS application is to define a content model which represents the particular domain. This content model is the base of the whole application. It concerns content management, delivery and persistence, and thus it affects nearly all components:  the basic appearance of the editor, the XML format supported by the importer, the interface for JSP programming, the query facilities, and last but not least relationships among content objects themselves. Convenience and simplicity of further customizing as well as the efficiency of the application crucially depends on a deliberate content model. Design weaknesses may lead to vast and error prone extra effort. See the Administration and Operation Manual for a comprehensive discussion of content modeling.
A publication synchronizes the state of the Live Server with the state of the Content Management Server.  All actions such as setting up new versions, deleting, moving or renaming files, withdrawing content from the live site require a publication to make the changes appear on the Live Server.
We make a distinction between the publication of structural and of content changes: Content-related changes are changes in document versions such as a newly inserted image, modifed links, text etc. Structure-related changes are moving, renaming, withdrawing or deleting of resources. So it becomes possible to publish structural changes separately from latest and approved document versions. For every publication a number of changes is aggregated in a change set. This change set is normally composed in the course of a publication workflow. The administrator and other users with appropriately configured editors can also execute a direct publication, which provides a simpler, although less flexible means of creating a change set.Withdrawing Publications and Deleting Resources There is only one fundamental difference between withdrawal of publications and deletion: an withdrawal affects only the Live Server, whereas the deletion of a resource causes the resource to be moved into the trash folder on the Content Management Server. Contrary to versions of the CoreMedia SCI before 4.2, folders are no longer destroyed, but enter the recycle bin in the same manner as documents. Before a withdrawal or deletion can be published as described before, a mark for withdrawal or for deletion must be applied using the appropriate menu entries or tool bar buttons. In the case of folders, the contained resources are affected, too. If you have marked a resource for deletion and withdrawal, then the deletion will be executed. When a folder is marked for deletion, all contained published resources are marked for deletion, too. Not published resources are immediately moved into the recycle bin without requiring to start a publication. When a folder is marked for withdrawal, all contained published resources are marked for withdrawal, too. When a mark for withdrawal or deletion of a folder is revoked, this also affects all contained resources with the same mark. If you use direct publication and approve a folder that is marked for withdrawal deletion, that approval is implicitly extended to the contained resources that are also marked for withdrawal or deletion. Disapprovals extend to contained resources in the same way. Change Set in Direct Publications When performing a direct publication, the change set is primarily based on the set of currently selected resources or on the single currently viewed resource. As the set of resources does not give enough information for all possible types of changes, three rules apply: You cannot publish movements and content changes separately. Whenever applicable, both kinds of changes are included in the change set. When a document is marked for deletion or for withdrawal, new versions of that document are not published. If the specific version to be published is not explicitly selected, the last approved resource version is included in the change set. There are also some automated extension rules for the change set, which modify the set of to-be-published resources itself. These rules can be configured in detail. Ask your Administrator about the current settings. When new or modified content is published and links to an as yet unpublished resource, the unpublished resource is included in the change set. Depending on the configuration, also recursively linked documents can be included in the change set. When the deletion of a folder is published, all directly and indirectly contained resources are included in the change set. When the withdrawal of a folder is published, all directly and indirectly contained published resources are included in the change set. When the creation, movement, or renaming of a resource in an unpublished parent folder is published, that folder is included in the change set. Preconditions Preconditions for a successful publication are: all path information concerning the resource has to be approved too: if the resource is located in a folder never published before, this folder has to be published with the resource. So, add it to the change set or publish the folder before. withdrawals and deletions must be approved before publication. all documents linked to from a document which is going to be published have to be already published or included in the change set. This is because a publication that would cause dead links will not be performed. a document which is going to be deleted must not be linked to from other documents or these documents have to be deleted during the same publication. Status and action on the Content Management Server	Effect on the Live Server on publication A version of the document does not yet exist on the Live Server. The document is not marked for deletion. You approve the version. The approved version is copied to the Live Server. The last approved version of a document already exists on the Live Server. The document is not marked for deletion. You start a new publication without any further preparation. No effect on the Live Server. The document is published and is not marked for deletion. It therefore exists on both servers. You rename the document and approve the change. The document is renamed. The document is published and is not marked for deletion. It therefore exists on both servers. You move the document and approve the change. The document is moved. The document is published. It therefore exists on both servers. No links to this document exists. You mark the document for withdrawal and approve the change. The document is destroyed on the Live Server. The document is published. It therefore exists on both servers. No links to this document exists. You mark the document for deletion and approve the change. The document is destroyed on the Live Server. The document is moved into the recycle bin on the Content Management Server. The document is published. It therefore exists on both servers. Links to this document from other published documents exist. You mark the document for deletion and approve the change. The deletion cannot be published, since an invalid link would be created. A message is displayed in the publication window. Remove the link in the other document and publish again. Status and action on the Content Management Server	Effects on the Live Server on publication The folder is published and is not marked for deletion. It therefore exists on both servers. You rename the folder and approve it. The folder is renamed. The folder is published and is not marked for deletion. It therefore exists on both servers. You move the folder and approve the change. The folder is moved. The folder is not published and not marked for deletion. You approve the folder. The folder is created on the Live Server. The folder is published. You mark it for withdrawal. When queried, you acknowledge the mark for withdrawal of all contained resources. You approve the change. The folder is destroyed on the Live Server. The withdrawal can only succeed if all resources on the Live Server that are transitively contained in the folder are also contained in the change set. The folder is published. You mark it for deletion. When queried, you acknowledge the mark for deletion of all contained resources. You approve the change. The folder is destroyed on the Live Server. The folder is moved to the recycle bin on the Content Management Server. The withdrawal can only succeed if all resources on the Live Server or Content Management Server that are transitively contained in the folder are also contained in the change set. Special cases Please keep in mind that: Older versions cannot be published. Example: if a version No. 4 had already been published it is not possible to publish version No. 3 thereafter. To do so, create a version No. 5 from No. 3. During a deletion, a resource that has not been published yet is moved to the recycle bin immediately. In addition, consult the previous tables for effects of a publication depending on the state of the resource. For all examples it is assumed that you have appropriate rights to perform the action.
The main goal of a content management system is to deliver the right content, to the right customer in the right time. Important requirements are: Support of high traffic delivery Support of different delivery formats, such as HTML, WAP, PDF Support of personalized content Support of search Integration of data from third-party systems Integration with an existing portal solution Integration with delivery platforms such as Akamai Analysis of usage Integration of user generated content To meet all these requirements, CoreMedia CMS contains the following components: The Content Application Engine (CAE) with its components Http Cache, CAE Feeder and Proactive Engine to deliver and search the content. Content Rules to deliver content, based on rules not on manual selection. The CoreMedia Portal Integration to integrate with portals. The Analytics Engine to analyze the usage of the content. The Social Software Extension to integrate user generated content. All these components have a framework character, and you can easily adapt them to your needs. See the Content Application Developer Manual for details of the CAE, Content Rules and the Portal Integration, the Analytics Developer Manual for details of the Analytics Engine and use the Social Software Extension manual to learn more about the integration of user generated content into your applications.
The use of the CoreMedia CMS  covers a range from sites maintained by a single editor to very large portals edited by many users in different roles. The more users are involved in editing, approving and publishing documents, the more difficult it becomes to coordinate tasks and schedules. Computer support can greatly enhance productivity because the users do not have to deal with organizational issues too much. This goal can be achieved by introducing workflows. These workflows do not precisely prescribe how tasks have to be performed, but coordinate and support the timely execution of different tasks by different users with as much flexibility as possible and as necessary. The CoreMedia Workflow has a non-restrictive, supportive approach - CoreMedia users are given access to the right resources at the right time via tasks. In contrast to restrictively controlling users, CoreMedia Workflow focuses on progress of the overall business processes. The CoreMedia CMS is delivered with some standard workflows which control content publication. They are based on the inherent state model of CoreMedia CMS resources (see the User Manual, Basic Knowledge). While the simplest workflow publishes a set of resources immediately, the most complex one ensures that composing the set of resources, approving those resources and the actual publication are executed explicitly by different users. If these workflows do not fit your needs, you can define your own workflows. A workflow basically consists of a set of tasks which are processed in a specific order (usually linear, but also circles and branches are possible) and a set of variables which represent the state of the workflow. There are automated tasks which are processed automatically at their turn (like publishing some resources) and user tasks which have to be handled explicitly by a user (e.g. composing a set of resources to be published). The tasks and variables of a workflow are defined in XML. The CoreMedia CMS provides some content related standard actions you can choose from to inspire your tasks, but you can also implement your own actions. You can specify performer policies to prevent or enforce users to process a task. From the technical point of view, processing a task means executing some actions but also changing workflow variables. For user tasks the CoreMedia Editor and the CoreMedia WebEditor support this in a fashion similar to editing the properties of a resource. And just alike, you might want to use special editing components for restrictions or convenience. Thus introducing custom workflows usually includes some Editor customizing. See the Workflow Developer Manual for details. 
Using the importer in order to import third party content you must basically take care for two aspects: Serve the source content Transform the source content into CoreMedia XML The importer framework provides an out-of-the-box solution for source content available as files. Alternatively you can implement your own factory, e.g. to serve content from a database, over some network protocol or to generate content on the fly, composed from arbitrary sources. As your source content is most probably not available in CoreMedia XML format matching your document types, you will have to transform it. The importer supports XSLT transformations (you just have to configure the stylesheet) as well as stream based cross-document transformations for arbitrary (even non-XML) sources. See the Importer Developer Manual for details.
CoreMedia CMS offers different APIs and frameworks for the creation of custom clients. The Unified API which enables you to implement custom CoreMedia CMS clients from scratch. Taking over session handling and remote communication, it reveals the full functionality of the Content Server and the Workflow Server in a convenient and intuitive abstraction which allows you to concentrate on business logic. See the Unified API Developer Manual for details. The WebServices Engine, which allows to access the CoreMedia CMS using Web Services. You can use the Unified API or the Content Application Engine to develop your Web Services. See the Delivery Developer Manual for details. The WAGE API, which enables you to access the CoreMedia CMS using web based clients. The current WebEditor is an implementation of the WAGE API. Read the WAGE Developer Manual for details. You should only use the WAGE API for customization of the WebEditor or if you need workflow functionality in your clients but not for newly designed stand-alone clients. For this tasks use the more modern Editing Services for JSF. Editing Services for JSF, a framework which allows to create custom clients to access the CoreMedia repository. It is the successor of the WAGE API and offers many convincing advantages. ES offers for example UI components and reusable beans. It uses modern technology like JSF and Spring and builds on the Unified API and CAE. The Portal Server Integration uses ES to add editing functionality to portals. Read the Content Application Developer Manual for details. The Unified API replaces the Scripting API which you might know from CoreMedia SCI 4.2. Old Scripting clients are still supported with CoreMedia CMS 2005, but for new implementations the usage of Scripting API is deprecated. That is why the Scripting API is no longer documented in the developer manuals. Consult the SCI 4.2 manual for maintenance of your legacy Scripting clients.